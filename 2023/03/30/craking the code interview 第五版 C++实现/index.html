<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"luozijian.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="[TOC] 面试考题本篇为学习笔记，题目出自 craking the code interview，中文译名 程序员面试经典（第五版），用 C&#x2F;C++ 实现 一. 字符串与数组1. 确定字符互异 题目描述： 请实现一个算法，确定一个字符串的所有字符是否全都不同。这里我们要求不允许使用额外的存储结构。 给定一个string iniString，请返回一个bool值,True代表所有字符全都">
<meta property="og:type" content="article">
<meta property="og:title" content="craking the code interview 第五版 C++实现">
<meta property="og:url" content="https://luozijian.github.io/2023/03/30/craking%20the%20code%20interview%20%E7%AC%AC%E4%BA%94%E7%89%88%20C++%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="Hello World">
<meta property="og:description" content="[TOC] 面试考题本篇为学习笔记，题目出自 craking the code interview，中文译名 程序员面试经典（第五版），用 C&#x2F;C++ 实现 一. 字符串与数组1. 确定字符互异 题目描述： 请实现一个算法，确定一个字符串的所有字符是否全都不同。这里我们要求不允许使用额外的存储结构。 给定一个string iniString，请返回一个bool值,True代表所有字符全都">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-03-30T10:04:10.137Z">
<meta property="article:modified_time" content="2023-03-30T10:04:10.137Z">
<meta property="article:author" content="Lumen">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://luozijian.github.io/2023/03/30/craking%20the%20code%20interview%20%E7%AC%AC%E4%BA%94%E7%89%88%20C++%E5%AE%9E%E7%8E%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>craking the code interview 第五版 C++实现 | Hello World</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hello World</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Lumen's blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://luozijian.github.io/2023/03/30/craking%20the%20code%20interview%20%E7%AC%AC%E4%BA%94%E7%89%88%20C++%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lumen">
      <meta itemprop="description" content="Learn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello World">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          craking the code interview 第五版 C++实现
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-03-30 18:04:10" itemprop="dateCreated datePublished" datetime="2023-03-30T18:04:10+08:00">2023-03-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[TOC]</p>
<h1 id="面试考题"><a href="#面试考题" class="headerlink" title="面试考题"></a>面试考题</h1><p>本篇为学习笔记，题目出自 <strong>craking the code interview</strong>，中文译名 <strong>程序员面试经典（第五版）</strong>，用 C&#x2F;C++ 实现</p>
<h2 id="一-字符串与数组"><a href="#一-字符串与数组" class="headerlink" title="一. 字符串与数组"></a>一. 字符串与数组</h2><h3 id="1-确定字符互异"><a href="#1-确定字符互异" class="headerlink" title="1. 确定字符互异"></a>1. 确定字符互异</h3><blockquote>
<p>题目描述：</p>
<p>请实现一个算法，确定一个字符串的所有字符是否全都不同。这里我们要求不允许使用额外的存储结构。</p>
<p>给定一个string <strong>iniString</strong>，请返回一个bool值,<strong>True</strong>代表所有字符全都不同，<strong>False</strong>代表存在相同的字符。保证字符串中的字符为ASCII字符。字符串的长度小于等于3000。</p>
<p>测试样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;aeiou&quot; 返回：True</span><br><span class="line">&quot;BarackObama&quot; 返回：False</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>较差的实现方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Different</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkDifferent</span><span class="params">(string iniString)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(iniString.<span class="built_in">length</span>() == <span class="number">0</span> || iniString.<span class="built_in">length</span>() &gt; <span class="number">256</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; iniString.<span class="built_in">length</span>() - <span class="number">1</span>;i++)&#123;</span><br><span class="line">          <span class="comment">//长度-1是因为最后一个元素不需要比较，前面已经比较过了</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>;j &lt; iniString.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(iniString[i] == iniString[j])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>较优的实现方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Different</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkDifferent</span><span class="params">(string iniString)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(iniString.<span class="built_in">length</span>() == <span class="number">0</span> || iniString.<span class="built_in">length</span>() &gt; <span class="number">256</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> b[<span class="number">256</span>] = &#123;<span class="literal">true</span>&#125;;<span class="comment">//C++里面要先赋值，否则会提示数组越界</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; iniString.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> c = iniString[i];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(b[c] == <span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            b[c] = <span class="literal">true</span>;<span class="comment">//出现过一次的数设为true，第二次一旦出现则返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>

<h3 id="2-原串翻转"><a href="#2-原串翻转" class="headerlink" title="2. 原串翻转"></a>2. 原串翻转</h3><blockquote>
<p>题目描述：</p>
<p>请实现一个算法，在不使用额外数据结构和储存空间的情况下，翻转一个给定的字符串(可以使用单个过程变量)。</p>
<p>给定一个string <strong>iniString</strong>，请返回一个string，为翻转后的字符串。保证字符串的长度小于等于5000。</p>
<p>测试样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;This is nowcoder&quot;</span><br><span class="line">返回：&quot;redocwon si sihT&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Reverse</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseString</span><span class="params">(string iniString)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end = iniString.<span class="built_in">length</span>() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> tmp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            tmp = iniString[start]; </span><br><span class="line">            iniString[start++] = iniString[end];</span><br><span class="line">            iniString[end--] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> iniString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-确定两串乱序同构"><a href="#3-确定两串乱序同构" class="headerlink" title="3. 确定两串乱序同构"></a>3. 确定两串乱序同构</h3><blockquote>
<p>题目描述</p>
<p>给定两个字符串，请编写程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。这里规定大小写为不同字符，且考虑字符串重点空格。</p>
<p>给定一个string <strong>stringA</strong>和一个string <strong>stringB</strong>，请返回一个bool，代表两串是否重新排列后可相同。保证两串的长度都小于等于5000。</p>
<p>测试样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;This is nowcoder&quot;,&quot;is This nowcoder&quot;</span><br><span class="line">返回：true</span><br><span class="line">&quot;Here you are&quot;,&quot;Are you here&quot;</span><br><span class="line">返回：false</span><br></pre></td></tr></table></figure>

</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Same</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkSam</span><span class="params">(string stringA, string stringB)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(stringA.<span class="built_in">length</span>() != stringB.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sort</span>(stringA.<span class="built_in">begin</span>(),stringA.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(stringB.<span class="built_in">begin</span>(),stringB.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (stringA == stringB)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-空格替换"><a href="#4-空格替换" class="headerlink" title="4. 空格替换"></a>4. 空格替换</h3><blockquote>
<p>题目描述</p>
<p>请编写一个方法，将字符串中的空格全部替换为“%20”。假定该字符串有足够的空间存放新增的字符，并且知道字符串的真实长度(小于等于1000)，同时保证字符串由大小写的英文字母组成。</p>
<p>给定一个string <strong>iniString</strong> 为原始的串，以及串的长度 int <strong>len</strong>, 返回替换后的string。</p>
<p>测试样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;Mr John Smith”,13</span><br><span class="line">返回：&quot;Mr%20John%20Smith&quot;</span><br><span class="line">”Hello  World”,12</span><br><span class="line">返回：”Hello%20%20World”</span><br></pre></td></tr></table></figure>

</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Replacement</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string iniString, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        string str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(iniString[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                str += <span class="built_in">string</span>(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                str += iniString[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-基本字符串压缩"><a href="#5-基本字符串压缩" class="headerlink" title="5. 基本字符串压缩"></a>5. 基本字符串压缩</h3><blockquote>
<p>题目描述</p>
<p>利用字符重复出现的次数，编写一个方法，实现基本的字符串压缩功能。比如，字符串“aabcccccaaa”经压缩会变成“a2b1c5a3”。若压缩后的字符串没有变短，则返回原先的字符串。</p>
<p>给定一个string iniString为待压缩的串(长度小于等于10000)，保证串内字符均由大小写英文字母组成，返回一个string，为所求的压缩后或未变化的串。</p>
<p>测试样例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;aabcccccaaa&quot;</span><br><span class="line">返回：&quot;a2b1c5a3&quot;</span><br><span class="line">&quot;welcometonowcoderrrrr&quot;</span><br><span class="line">返回：&quot;welcometonowcoderrrrr&quot;</span><br></pre></td></tr></table></figure>

</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Zipper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">zipString</span><span class="params">(string iniString)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        string myStr;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>,i;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> last = iniString[<span class="number">0</span>];<span class="comment">//最后一个不同的字符</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt; iniString.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(last == iniString[i])&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                myStr += last + <span class="built_in">to_string</span>(count);</span><br><span class="line">                last = iniString[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        string res = myStr + last + <span class="built_in">to_string</span>(count);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">length</span>() &gt;= iniString.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> iniString;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-像素翻转"><a href="#6-像素翻转" class="headerlink" title="6. 像素翻转"></a>6. 像素翻转</h3><blockquote>
<p>题目描述</p>
<p>有一副由NxN矩阵表示的图像，这里每个像素用一个int表示，请编写一个算法，在不占用额外内存空间的情况下(即不使用缓存矩阵)，将图像顺时针旋转90度。</p>
<p>给定一个NxN的矩阵，和矩阵的阶数N,请返回旋转后的NxN矩阵,保证N小于等于500，图像元素小于等于256。</p>
<p>测试样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[1,2,3],[4,5,6],[7,8,9]],3</span><br><span class="line">返回：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="7-清除行列"><a href="#7-清除行列" class="headerlink" title="7. 清除行列"></a>7. 清除行列</h3><blockquote>
<p>题目描述</p>
<p>请编写一个算法，若N阶方阵中某个元素为0，则将其所在的行与列清零。</p>
<p>给定一个N阶方阵<strong>int[][]</strong>(C++中为vector&gt;)<strong>mat</strong>和矩阵的阶数<strong>n</strong>，请返回完成操作后的**int[][]**方阵(C++中为vector&gt;)，保证n小于等于300，矩阵中的元素为int范围内。</p>
<p>测试样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[1,2,3],[0,1,2],[0,0,1]]</span><br><span class="line">返回：[[0,0,3],[0,0,0],[0,0,0]]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Clearer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">clearZero</span>(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; mat, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">row</span><span class="params">(n,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">column</span><span class="params">(n,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    row[i] = <span class="literal">true</span>;</span><br><span class="line">                    column[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(row[i] || column[j])&#123;</span><br><span class="line">                    mat[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mat;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="8-翻转子串"><a href="#8-翻转子串" class="headerlink" title="8. 翻转子串"></a>8. 翻转子串</h3><blockquote>
<p>题目描述</p>
<p>假定我们都知道非常高效的算法来检查一个单词是否为其他字符串的子串。请将这个算法编写成一个函数，给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成，要求只能调用一次检查子串的函数。</p>
<p>给定两个字符串s1,s2,请返回bool值代表s2是否由s1旋转而成。字符串中字符为英文字母和空格，区分大小写，字符串长度小于等于1000。</p>
<p>测试样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;Hello world&quot;,&quot;worldhello &quot;</span><br><span class="line">返回：false</span><br><span class="line">&quot;waterbottle&quot;,&quot;erbottlewat&quot;</span><br><span class="line">返回：true</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReverseEqual</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkReverseEqual</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(s1.<span class="built_in">length</span>() != s2.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        string s1s1 = s1 + s1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s1s1.<span class="built_in">find</span>(s2) == <span class="number">-1</span>)&#123;</span><br><span class="line">          <span class="comment">//原理:s2(旋转后的串) 一定是 s1(原串) ＋ s1 的子串,否则 s2 不能由 s1 旋转而来</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h2><h3 id="1-链表中倒数第-k-个结点"><a href="#1-链表中倒数第-k-个结点" class="headerlink" title="1. 链表中倒数第 k 个结点"></a>1. 链表中倒数第 k 个结点</h3><blockquote>
<p>题目描述</p>
<p>输入一个链表，输出该链表中倒数第k个结点。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pListHead, <span class="type">unsigned</span> <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span>(pListHead == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//双指针</span></span><br><span class="line">        ListNode *p1 = pListHead;</span><br><span class="line">        ListNode *p2 = pListHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= k;i++)&#123;</span><br><span class="line">          <span class="comment">//p2先向前移动k位</span></span><br><span class="line">            <span class="keyword">if</span>(p2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">          <span class="comment">//p1 p2同时移动，当p2到达</span></span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-访问单个节点的删除"><a href="#2-访问单个节点的删除" class="headerlink" title="2. 访问单个节点的删除"></a>2. 访问单个节点的删除</h3><blockquote>
<p>题目描述</p>
<p>实现一个算法，删除单向链表中间的某个结点，假定你只能访问该结点。</p>
<p>给定待删除的节点，请执行删除操作，若该节点为尾节点，返回false，否则返回true</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Remove</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">removeNode</span><span class="params">(ListNode* pNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(!pNode || !pNode-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* p = pNode-&gt;next;</span><br><span class="line">        </span><br><span class="line">        pNode-&gt;val = p-&gt;val;</span><br><span class="line">        </span><br><span class="line">        pNode-&gt;next = p-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-链表分割"><a href="#3-链表分割" class="headerlink" title="3. 链表分割"></a>3. 链表分割</h3><blockquote>
<p>题目描述</p>
<p>编写代码，以给定值x为基准将链表分割成两部分，所有小于x的结点排在大于或等于x的结点之前</p>
<p>给定一个链表的头指针 ListNode* <strong>pHead</strong>，请返回重新排列后的链表的头指针。注意：分割以后保持原来的数据顺序不变。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Partition</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* pHead, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ListNode* temp1 = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* head1 = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* head2 = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* temp2 = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pHead != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode* node = pHead-&gt;next;<span class="comment">//此处保留下一个节点，因为要赋值的节点的next要设置为null</span></span><br><span class="line">            pHead-&gt;next = <span class="literal">nullptr</span>;<span class="comment">//将next为空，这样才能只赋值一个节点</span></span><br><span class="line">            <span class="keyword">if</span>(pHead-&gt;val &lt; x)&#123;</span><br><span class="line">                <span class="keyword">if</span>(head1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    head1 = pHead;</span><br><span class="line">                    temp1 = head1;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    temp1-&gt;next = pHead;</span><br><span class="line">                    temp1 = temp1-&gt;next;</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(head2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    head2 = pHead;</span><br><span class="line">                    temp2 = head2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    temp2-&gt;next = pHead;</span><br><span class="line">                    temp2 = temp2-&gt;next;</span><br><span class="line">                &#125;      </span><br><span class="line">            &#125;</span><br><span class="line">            pHead = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处要判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(head1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head2;</span><br><span class="line">        &#125;</span><br><span class="line">        temp1-&gt;next = head2;</span><br><span class="line">        <span class="keyword">return</span> head1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-链式A-B"><a href="#4-链式A-B" class="headerlink" title="4. 链式A+B"></a>4. 链式A+B</h3><blockquote>
<p>题目描述</p>
<p>有两个用链表表示的整数，每个结点包含一个数位。这些数位是反向存放的，也就是个位排在链表的首部。编写函数对这两个整数求和，并用链表形式返回结果。</p>
<p>给定两个链表ListNode* <strong>A</strong>，ListNode* <strong>B</strong>，请返回A+B的结果(ListNode*)。</p>
<p>测试样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;1,2,3&#125;,&#123;3,2,1&#125;</span><br><span class="line">返回：&#123;4,4,4&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Plus</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">plusAB</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(a == <span class="literal">nullptr</span> || b == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);<span class="comment">//创建一个空链表</span></span><br><span class="line">        ListNode* p = head;<span class="comment">//创建p指针指向head</span></span><br><span class="line">        ListNode* pa = a;</span><br><span class="line">        ListNode* pb = b;</span><br><span class="line">        ListNode* node = <span class="literal">nullptr</span>;<span class="comment">//声明存放结果节点的变量，初值为空</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> c = <span class="number">0</span>,sum,val1,val2;<span class="comment">//声明 进位、和、值1、值2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pa != <span class="literal">nullptr</span> || pb != <span class="literal">nullptr</span> || c != <span class="number">0</span>)&#123;</span><br><span class="line">            val1 = pa == <span class="literal">nullptr</span> ? <span class="number">0</span> : pa-&gt;val;</span><br><span class="line">            val2 = pb == <span class="literal">nullptr</span> ? <span class="number">0</span> : pb-&gt;val;</span><br><span class="line"></span><br><span class="line">            sum = val1 + val2 + c;</span><br><span class="line">            c = sum / <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);<span class="comment">//创建链表，值为当前位结果值</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//尾插法</span></span><br><span class="line">            p-&gt;next = node;<span class="comment">//给head创建后继节点</span></span><br><span class="line">            p = node;<span class="comment">//p移动到node</span></span><br><span class="line">            </span><br><span class="line">            pa = pa == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : pa-&gt;next;</span><br><span class="line">            pb = pb == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : pb-&gt;next;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-回文链表"><a href="#5-回文链表" class="headerlink" title="5. 回文链表"></a>5. 回文链表</h3><blockquote>
<p>题目描述</p>
<p>请编写一个函数，检查链表是否为回文。</p>
<p>给定一个链表ListNode* <strong>pHead</strong>，请返回一个bool，代表链表是否为回文。</p>
<p>测试样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;1,2,3,2,1&#125;</span><br><span class="line">返回：true</span><br><span class="line">&#123;1,2,3,2,3&#125;</span><br><span class="line">返回：false</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>反转链表并比较</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Palindrome</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="literal">nullptr</span> || pHead-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        string s;</span><br><span class="line">        <span class="keyword">while</span>(pHead)&#123;</span><br><span class="line">            s += <span class="built_in">to_string</span>(pHead-&gt;val);</span><br><span class="line">            pHead = pHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        string s2 = s;</span><br><span class="line">        <span class="built_in">reverse</span>(s2.<span class="built_in">begin</span>(),s2.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s2 == s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代法：利用快慢指针，找到中间节点；将慢指针节点的值压入栈，到达中间节点后，依次出栈与后续节点的值比较。特别注意长度奇偶数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Palindrome</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="literal">nullptr</span> || pHead-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;<span class="comment">//定义一个栈</span></span><br><span class="line">        ListNode* fast = pHead;<span class="comment">//快指针</span></span><br><span class="line">        ListNode* slow = pHead;<span class="comment">//慢指针</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(slow-&gt;val);<span class="comment">//入栈</span></span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;<span class="comment">//快指针用慢指针两倍速度移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(fast)&#123;</span><br><span class="line">            <span class="comment">//节点个数是奇数</span></span><br><span class="line">            slow = slow-&gt;next;<span class="comment">//跳过中间节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(slow)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">top</span>() != slow-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="三、栈和队列"><a href="#三、栈和队列" class="headerlink" title="三、栈和队列"></a>三、栈和队列</h2><h3 id="1-集合栈"><a href="#1-集合栈" class="headerlink" title="1. 集合栈"></a>1. 集合栈</h3><blockquote>
<p>题目描述</p>
<p>请实现一种数据结构SetOfStacks，由多个栈组成，其中每个栈的大小为size，当前一个栈填满时，新建一个栈。该数据结构应支持与普通栈相同的push和pop操作。</p>
<p>给定一个操作序列int[][2] <strong>ope</strong>(C++为vector&lt;vector<int>&gt;)，每个操作的第一个数代表操作类型，若为1，则为push操作，后一个数为应push的数字；若为2，则为pop操作，后一个数无意义。请返回一个int[]<a href="C++%E4%B8%BAvector%3Cvector%3Cint%3E%3E"></a>，为完成所有操作后的SetOfStacks，顺序应为从下到上，默认初始的SetOfStacks为空。保证数据合法。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SetOfStacks</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">setOfStacks</span>(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; ope, <span class="type">int</span> size) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; stack;<span class="comment">//定义结果栈</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;<span class="comment">//用来置换的栈</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; ope.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ope[i][<span class="number">0</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//入栈</span></span><br><span class="line">                <span class="keyword">if</span>(temp.<span class="built_in">size</span>() == size)&#123;</span><br><span class="line">                    <span class="comment">//置换的栈满，清空栈再入栈</span></span><br><span class="line">                    stack.<span class="built_in">push_back</span>(temp);</span><br><span class="line">                    temp.<span class="built_in">clear</span>();</span><br><span class="line">                    temp.<span class="built_in">push_back</span>(ope[i][<span class="number">1</span>]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//栈未满，直接入栈</span></span><br><span class="line">                    temp.<span class="built_in">push_back</span>(ope[i][<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ope[i][<span class="number">0</span>] == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">//出栈</span></span><br><span class="line">                <span class="keyword">if</span>(temp.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="comment">//当前栈为空，弹出stack总栈栈顶并赋予temp，然后temp再弹出栈顶元素（相当于回滚一个入栈操作）</span></span><br><span class="line">                    temp = stack[stack.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">                    stack.<span class="built_in">pop_back</span>();</span><br><span class="line">                    temp.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//当前栈不为空，直接出栈</span></span><br><span class="line">                    temp.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!temp.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">//有残留元素未入栈（未达到size），现在入总栈</span></span><br><span class="line">            stack.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-用两个栈实现队列"><a href="#2-用两个栈实现队列" class="headerlink" title="2. 用两个栈实现队列"></a>2. 用两个栈实现队列</h3><blockquote>
<p>题目描述</p>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//入列</span></span><br><span class="line">        stack1.<span class="built_in">push</span>(node);<span class="comment">//将最新元素压入栈1，栈1始终是比较新的元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//出列</span></span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        <span class="keyword">if</span>(stack2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">//旧栈（栈2）为空，则把栈1反转后压入栈2，在栈2出栈，清空栈1</span></span><br><span class="line">            <span class="keyword">while</span>(!stack1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                tmp = stack1.<span class="built_in">top</span>();</span><br><span class="line">                stack2.<span class="built_in">push</span>(tmp);</span><br><span class="line">                stack1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//旧栈不为空，可直接出栈</span></span><br><span class="line">        tmp = stack2.<span class="built_in">top</span>();</span><br><span class="line">        stack2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-双栈排序"><a href="#3-双栈排序" class="headerlink" title="3. 双栈排序"></a>3. 双栈排序</h3><blockquote>
<p>题目描述</p>
<p>请编写一个程序，按升序对栈进行排序（即最大元素位于栈顶），要求最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。</p>
<p>给定一个int[] <strong>numbers</strong>(C++中为vector&amp;ltint&gt;)，其中第一个元素为栈顶，请返回排序后的栈。请注意这是一个栈，意味着排序过程中你只能访问到第一个元素。</p>
<p>测试样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5]</span><br><span class="line">返回：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TwoStacks</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoStacksSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!numbers.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            tmp = numbers.<span class="built_in">back</span>();<span class="comment">//拿到最先进来的元素(数组的最后一个元素)</span></span><br><span class="line">            numbers.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">while</span>(!res.<span class="built_in">empty</span>() &amp;&amp; res.<span class="built_in">back</span>() &gt; tmp)&#123;</span><br><span class="line">                numbers.<span class="built_in">push_back</span>(res.<span class="built_in">back</span>());</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());<span class="comment">//因为一直用的是数组，最后翻转成栈</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-猫狗收容所"><a href="#4-猫狗收容所" class="headerlink" title="4. 猫狗收容所"></a>4. 猫狗收容所</h3><blockquote>
<p>题目描述</p>
<p> 有家动物收容所只收留猫和狗，但有特殊的收养规则，收养人有两种收养方式，第一种为直接收养所有动物中最早进入收容所的，第二种为选择收养的动物类型（猫或狗），并收养该种动物中最早进入收容所的。</p>
<p>​       给定一个操作序列int[][2] <strong>ope</strong>(C++中为vector&lt;vector<int>&gt;)代表所有事件。若第一个元素为1，则代表有动物进入收容所，第二个元素为动物的编号，正数代表狗，负数代表猫；若第一个元素为2，则代表有人收养动物，第二个元素若为0，则采取第一种收养方式，若为1，则指定收养狗，若为-1则指定收养猫。请按顺序返回收养的序列。若出现不合法的操作，即没有可以符合领养要求的动物，则将这次领养操作忽略。</p>
<p>测试样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[1,1],[1,-1],[2,0],[2,-1]]</span><br><span class="line">返回：[1,-1]</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>如果只维护一个队列，只需要取出队头的动物则可以，但如果指定要收养猫或者狗就要迭代访问整个队列，效率比较低</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CatDogAsylum</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">asylum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; ope)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; animals;<span class="comment">//收容所动物数组</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;<span class="comment">//结果数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; ope.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ope[i][<span class="number">0</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//有动物进入收容所</span></span><br><span class="line">                animals.<span class="built_in">push_back</span>(ope[i][<span class="number">1</span>]);<span class="comment">//狗就是正数，猫是负数</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ope[i][<span class="number">0</span>] == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">//有人收养动物</span></span><br><span class="line">                <span class="keyword">if</span>(animals.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="comment">//收容所没有动物</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ope[i][<span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//第一种收养方式</span></span><br><span class="line">                    res.<span class="built_in">push_back</span>(animals[<span class="number">0</span>]);</span><br><span class="line">                    animals.<span class="built_in">erase</span>(animals.<span class="built_in">begin</span>());<span class="comment">//删除动物</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ope[i][<span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//收养狗</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; animals.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(animals[j] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                            <span class="comment">//狗是正数</span></span><br><span class="line">                            res.<span class="built_in">push_back</span>(animals[j]);</span><br><span class="line">                            animals.<span class="built_in">erase</span>(animals.<span class="built_in">begin</span>() + j);<span class="comment">//删除狗</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ope[i][<span class="number">1</span>] == <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="comment">//收养猫</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; animals.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(animals[j] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                            <span class="comment">//猫是负数</span></span><br><span class="line">                            res.<span class="built_in">push_back</span>(animals[j]);</span><br><span class="line">                            animals.<span class="built_in">erase</span>(animals.<span class="built_in">begin</span>() + j);<span class="comment">//删除猫</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用两个队列，猫和狗各自一个队列来维护，用一个变量记录时间顺序，就可以返回最老的一只猫或狗</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CatDogAsylum</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">asylum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; ope)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; cats;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; dogs;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> step = <span class="number">0</span>;<span class="comment">//动物进入收容所的时间记录</span></span><br><span class="line">        <span class="type">int</span> oldest;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; ope.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ope[i][<span class="number">0</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//有动物进入收容所</span></span><br><span class="line">                <span class="keyword">if</span>(ope[i][<span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//狗</span></span><br><span class="line">                    dogs.<span class="built_in">push</span>(step++);</span><br><span class="line">                    dogs.<span class="built_in">push</span>(ope[i][<span class="number">1</span>]);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ope[i][<span class="number">1</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//猫</span></span><br><span class="line">                    cats.<span class="built_in">push</span>(step++);</span><br><span class="line">                    cats.<span class="built_in">push</span>(ope[i][<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ope[i][<span class="number">0</span>] == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">//有人收养动物</span></span><br><span class="line">                <span class="keyword">if</span>(cats.<span class="built_in">empty</span>() &amp;&amp; dogs.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="comment">//收容所没有动物</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ope[i][<span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//第一种收养方式</span></span><br><span class="line">                    <span class="keyword">if</span>(!cats.<span class="built_in">empty</span>() &amp;&amp; dogs.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                        <span class="comment">//有猫无狗</span></span><br><span class="line">                        oldest = <span class="number">-1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cats.<span class="built_in">empty</span>() &amp;&amp; !dogs.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                        <span class="comment">//有狗无猫</span></span><br><span class="line">                        oldest = <span class="number">1</span>;</span><br><span class="line">                	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!cats.<span class="built_in">empty</span>() &amp;&amp; !dogs.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                        <span class="comment">//有狗也有猫</span></span><br><span class="line">                        oldest = cats.<span class="built_in">front</span>() &lt; dogs.<span class="built_in">front</span>() ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(oldest == <span class="number">1</span>)&#123;</span><br><span class="line">                        dogs.<span class="built_in">pop</span>();<span class="comment">//删除step</span></span><br><span class="line">                        res.<span class="built_in">push_back</span>(dogs.<span class="built_in">front</span>());</span><br><span class="line">                        dogs.<span class="built_in">pop</span>();<span class="comment">//删除狗编号</span></span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        cats.<span class="built_in">pop</span>();</span><br><span class="line">                        res.<span class="built_in">push_back</span>(cats.<span class="built_in">front</span>());</span><br><span class="line">                        cats.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">            	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ope[i][<span class="number">1</span>] == <span class="number">1</span> &amp;&amp; !dogs.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="comment">//收养狗</span></span><br><span class="line">                    dogs.<span class="built_in">pop</span>();<span class="comment">//删除step</span></span><br><span class="line">                    res.<span class="built_in">push_back</span>(dogs.<span class="built_in">front</span>());</span><br><span class="line">                    dogs.<span class="built_in">pop</span>();<span class="comment">//删除狗编号</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ope[i][<span class="number">1</span>] == <span class="number">-1</span> &amp;&amp; !cats.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="comment">//收养猫</span></span><br><span class="line">                    cats.<span class="built_in">pop</span>();</span><br><span class="line">                    res.<span class="built_in">push_back</span>(cats.<span class="built_in">front</span>());</span><br><span class="line">                    cats.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="四、树与图"><a href="#四、树与图" class="headerlink" title="四、树与图"></a>四、树与图</h2><h3 id="1-二叉树平衡检查"><a href="#1-二叉树平衡检查" class="headerlink" title="1. 二叉树平衡检查"></a>1. 二叉树平衡检查</h3><blockquote>
<p>题目描述</p>
<p>实现一个函数，检查二叉树是否平衡，平衡的定义如下，对于树中的任意一个结点，其两颗子树的高度差不超过1。</p>
<p>给定指向树根结点的指针TreeNode* <strong>root</strong>，请返回一个bool，代表这棵树是否平衡。</p>
</blockquote>
<ul>
<li><p>方法一：首先想到的是如何求一个树的高度，求一个树的高度很简单，递归求解，每次求出左右子树的最大高度再加1便是父节点的高度，这样递归下去，便可以求出任何一颗树的高度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Balance</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalance</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//递归完所有结点了，并无不平衡</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(<span class="built_in">getHeight</span>(root-&gt;left) - <span class="built_in">getHeight</span>(root-&gt;right)) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//abs是求两棵树高度差的绝对值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isBalance</span>(root-&gt;left) &amp;&amp; <span class="built_in">isBalance</span>(root-&gt;right);<span class="comment">//递归判断左右子树是否“同时”平衡</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//递归到最后的子结点，高度是0</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> left_height = <span class="built_in">getHeight</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right_height = <span class="built_in">getHeight</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left_height &gt; right_height ? left_height + <span class="number">1</span> :  right_height + <span class="number">1</span>;<span class="comment">//＋1就是父结点高度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：递归到最后的子结点，向上递归的时候，如果左右子树高度不平衡，返回－1，平衡则返回父结点的高度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Balance</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalance</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">checkHeight</span>(root) != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">checkHeight</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先检查左右子树是否平衡，从下往上判断，不平衡就返回-1，这样以免每次都从上计算到最底下</span></span><br><span class="line">        <span class="type">int</span> left_height = <span class="built_in">checkHeight</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(left_height == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> right_height = <span class="built_in">checkHeight</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(right_height == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//再判断此节点是否平衡，平衡返回高度</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(left_height - right_height) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left_height &gt; right_height ? left_height + <span class="number">1</span> : right_height + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-有向路径检查"><a href="#2-有向路径检查" class="headerlink" title="2. 有向路径检查"></a>2. 有向路径检查</h3><blockquote>
<p>题目描述</p>
<p>对于一个有向图，请实现一个算法，找出两点之间是否存在一条路径。</p>
<p>给定图中的两个结点的指针UndirectedGraphNode* <strong>a</strong>,UndirectedGraphNode* <strong>b</strong>(请不要在意数据类型，图是有向图),请返回一个bool，代表两点之间是否存在一条路径(a到b或b到a)。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct UndirectedGraphNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    vector&lt;struct UndirectedGraphNode *&gt; neighbors;</span></span><br><span class="line"><span class="comment">    UndirectedGraphNode(int x) : label(x) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Path</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkPath</span><span class="params">(UndirectedGraphNode* a, UndirectedGraphNode* b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(a,b) || <span class="built_in">search</span>(b,a);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(UndirectedGraphNode* a, UndirectedGraphNode* b)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span>(a == b)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        map&lt;UndirectedGraphNode*,<span class="type">bool</span>&gt; m;<span class="comment">//记录所有结点是否被访问过</span></span><br><span class="line">        queue&lt;UndirectedGraphNode*&gt; q;<span class="comment">//邻居队列</span></span><br><span class="line">        UndirectedGraphNode* current;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        </span><br><span class="line">        q.<span class="built_in">push</span>(a);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            current = q.<span class="built_in">front</span>();</span><br><span class="line">            m[current] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; current-&gt;neighbors.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="comment">//遍历邻居</span></span><br><span class="line">                <span class="keyword">if</span>(current-&gt;neighbors[i] == b)&#123;</span><br><span class="line">                    <span class="comment">//邻居就是b，找到路径</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(current-&gt;neighbors[i] != <span class="literal">NULL</span> &amp;&amp; m[current-&gt;neighbors[i]] != <span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="comment">//当前这个邻居不为空，而且未被访问过</span></span><br><span class="line">                    q.<span class="built_in">push</span>(current-&gt;neighbors[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">pop</span>();<span class="comment">//把当前访问过的邻居父结点弹出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历完所有邻居的邻居的邻居。。。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-高度最小的-BST"><a href="#3-高度最小的-BST" class="headerlink" title="3. 高度最小的 BST"></a>3. 高度最小的 BST</h3><blockquote>
<p>题目描述</p>
<p>对于一个元素各不相同且按升序排列的有序序列，请编写一个算法，创建一棵高度最小的二叉查找树。</p>
<p>给定一个有序序列int[] <strong>vals</strong>,请返回创建的二叉查找树的高度。</p>
</blockquote>
<p>思路：高度最小即理解为左右子树的结点数量越接近越好，也就是，根结点是数组中间，左半边是左子树，右半边是右子树，第一种方法是从根结点开始递归插入值到树中，构建二叉树，但是这种方法效率不高，每次插入都要遍历整棵树，因此采用第二种方法，传入数组的区间段。</p>
<ul>
<li><p>如果是返回高度的话</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinimalBST</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">buildMinimalBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vals)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(vals,<span class="number">0</span>,vals.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vals,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//遍历到叶子结点了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">build</span>(vals,start,mid - <span class="number">1</span>),<span class="built_in">build</span>(vals,mid + <span class="number">1</span>,end)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是构建二叉树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinimalBST</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        TreeNode* left = null;</span><br><span class="line">        TreeNode* right = null;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;val = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">buildMinimalBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vals)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(vals,<span class="number">0</span>,vals.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vals,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            <span class="keyword">return</span> null;<span class="comment">//遍历到叶子结点了</span></span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(vals[mid]);</span><br><span class="line">        <span class="type">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        node.left = <span class="built_in">build</span>(vals,start, mid<span class="number">-1</span>);</span><br><span class="line">        node.right = <span class="built_in">build</span>(vals,mid+<span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-树输出单层结点"><a href="#4-树输出单层结点" class="headerlink" title="4. 树输出单层结点"></a>4. 树输出单层结点</h3><blockquote>
<p>题目描述</p>
<p>对于一棵二叉树，请设计一个算法，创建含有某一深度上所有结点的链表。</p>
<p>给定二叉树的根结点指针TreeNode* <strong>root</strong>，以及链表上结点的深度，请返回一个链表ListNode，代表该深度上所有结点的值，请按树上从左往右的顺序链接，保证深度不超过树的高度，树上结点的值为非负整数且不超过100000。</p>
</blockquote>
<p>思路：有两种方法，第一种方法使用递归遍历整颗树，如果递归的当前结点是需要输出的那一层的结点，则把结点插入到链表中，最后返回链表即可。第二种方法，使用层次遍历，即广度优先遍历的方法，利用队列实现。</p>
<ul>
<li><p>方法一：递归（深度优先）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeLevel</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getTreeLevel</span><span class="params">(TreeNode* root, <span class="type">int</span> dep)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ListNode* list = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);<span class="comment">//存放单层结点的链表</span></span><br><span class="line">        ListNode* listHead = list;<span class="comment">//结果链表</span></span><br><span class="line">        <span class="built_in">insert</span>(root,list,dep);</span><br><span class="line">        <span class="keyword">return</span> listHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(TreeNode* root,ListNode* &amp;list,<span class="type">int</span> dep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span> || dep &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dep == <span class="number">1</span>)&#123;</span><br><span class="line">            ListNode* temp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(root-&gt;val);</span><br><span class="line">            list-&gt;next = temp;</span><br><span class="line">            list = list-&gt;next;<span class="comment">//为什么要移动指针，因为下面要作为参数递归，每一次递归的当前指针指向的都是上一次递归指向的结点</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">insert</span>(root-&gt;left,list,dep<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">insert</span>(root-&gt;right,list,dep<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：层次遍历（广度优先），利用current变量记录当前层数的结点数，next变量记录下一层结点数，line纪录当前遍历层数，每遍历一个当前层数结点，current减一，如果发现current＝＝0，就把下一层入列的结点数变为当前层结点数，进入下一层。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeLevel</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getTreeLevel</span><span class="params">(TreeNode* root, <span class="type">int</span> dep)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ListNode* list = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* listHead = list;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> current=<span class="number">1</span>,next=<span class="number">0</span>,line=<span class="number">1</span>;<span class="comment">//当前层结点个数，下一层结点个数，当前遍历层数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(line == dep)&#123;</span><br><span class="line">                <span class="comment">//当前层就是要的层，把队列所有结点插入链表，返回结果链表</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; current;i++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    list-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(node-&gt;val);</span><br><span class="line">                    list = list-&gt;next;</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> listHead-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            TreeNode* node = que.<span class="built_in">front</span>();<span class="comment">//取出跟结点</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">                <span class="comment">//有左子结点</span></span><br><span class="line">                que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                next++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">                <span class="comment">//有右子结点</span></span><br><span class="line">                que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                next++;</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">pop</span>();<span class="comment">//弹出根结点</span></span><br><span class="line">            <span class="keyword">if</span>(--current == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//当前层已全部弹出（全部遍历），进入下一层</span></span><br><span class="line">                current = next;</span><br><span class="line">                next = <span class="number">0</span>;</span><br><span class="line">                line++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> listHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-检查是否为BST"><a href="#5-检查是否为BST" class="headerlink" title="5. 检查是否为BST"></a>5. 检查是否为BST</h3><blockquote>
<p>题目描述</p>
<p>请实现一个函数，检查一棵二叉树是否为二叉查找树。</p>
<p>给定树的根结点指针TreeNode* <strong>root</strong>，请返回一个bool，代表该树是否为二叉查找树。</p>
</blockquote>
<ul>
<li><p>解法一：中序遍历二叉树，一旦不满足 left &lt;&#x3D; current &lt; right 的情况则返回 false</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Checker</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> <span class="title function_ invoke__">checkBST</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">      	<span class="comment">//最大最小值时，最初的比较数字就应当设置为INT_MAX或INT_MIN，更为安全</span></span><br><span class="line">      	<span class="comment">//INT_MAX = 2147483647</span></span><br><span class="line">      	<span class="comment">//INT_MIN = -2147483648</span></span><br><span class="line">        <span class="keyword">int</span> min = INT_MIN;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">ldr</span>(root,min);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> <span class="title function_ invoke__">ldr</span>(TreeNode* root,<span class="keyword">int</span> &amp;last)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == nullptr)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//当前结点为空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_ invoke__">ldr</span>(root-&gt;left,last))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt; last)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last = root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_ invoke__">ldr</span>(root-&gt;right,last))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法二：递归遍历二叉树的过程中，我们只需要传递两个参数（当前根节点对应的二叉树的所有节点的最大值和最小值），同时不断的更新这两个参数，如果当前节点的值不在这两个数范围中，则直接返回false，否则接着递归便可</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Checker</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> <span class="title function_ invoke__">checkBST</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> min = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> max = INT_MAX;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">checker</span>(root,min,max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="title function_ invoke__">checker</span>(TreeNode* root,<span class="keyword">int</span> min,<span class="keyword">int</span> max)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == nullptr)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt; min || root-&gt;val &gt; max)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">checker</span>(root-&gt;left,min,root-&gt;val) &amp;&amp; <span class="title function_ invoke__">checker</span>(root-&gt;right,root-&gt;val,max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-寻找下一个结点"><a href="#6-寻找下一个结点" class="headerlink" title="6. 寻找下一个结点"></a>6. 寻找下一个结点</h3><blockquote>
<p>题目描述</p>
<p>请设计一个算法，寻找二叉树中指定结点的下一个结点（即中序遍历的后继）。</p>
<p>给定树的根结点指针TreeNode* <strong>root</strong>和结点的值int <strong>p</strong>，请返回值为p的结点的后继结点的值。保证结点的值大于等于零小于等于100000且没有重复值，若不存在后继返回-1。</p>
</blockquote>
<p>思路：中序遍历所有二叉树，若没找到与p值相同的结点，全部返回-1，一旦找到了，设置引用为true，递归返回结点的值</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Successor</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="title function_ invoke__">findSucc</span>(TreeNode* root, <span class="keyword">int</span> p) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">ldr</span>(root,p,flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="title function_ invoke__">ldr</span>(TreeNode* root,<span class="keyword">int</span> p,<span class="keyword">bool</span> &amp;flag)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == nullptr)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="title function_ invoke__">ldr</span>(root-&gt;left,p,flag);</span><br><span class="line">        <span class="keyword">if</span>(left != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == p)&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">ldr</span>(root-&gt;right,p,flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/03/30/Laravel%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/" rel="prev" title="Laravel 常见问题汇总">
      <i class="fa fa-chevron-left"></i> Laravel 常见问题汇总
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/03/30/%E4%BD%BF%E7%94%A8%20GitHub%20Pages%20+%20Hexo%20%E5%85%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" rel="next" title="使用 GitHub Pages + Hexo 免服务器搭建个人博客">
      使用 GitHub Pages + Hexo 免服务器搭建个人博客 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E8%80%83%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">面试考题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%95%B0%E7%BB%84"><span class="nav-number">1.1.</span> <span class="nav-text">一. 字符串与数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%A1%AE%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%BA%92%E5%BC%82"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. 确定字符互异</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%8E%9F%E4%B8%B2%E7%BF%BB%E8%BD%AC"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. 原串翻转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%A1%AE%E5%AE%9A%E4%B8%A4%E4%B8%B2%E4%B9%B1%E5%BA%8F%E5%90%8C%E6%9E%84"><span class="nav-number">1.1.3.</span> <span class="nav-text">3. 确定两串乱序同构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%A9%BA%E6%A0%BC%E6%9B%BF%E6%8D%A2"><span class="nav-number">1.1.4.</span> <span class="nav-text">4. 空格替换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9"><span class="nav-number">1.1.5.</span> <span class="nav-text">5. 基本字符串压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%83%8F%E7%B4%A0%E7%BF%BB%E8%BD%AC"><span class="nav-number">1.1.6.</span> <span class="nav-text">6. 像素翻转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%B8%85%E9%99%A4%E8%A1%8C%E5%88%97"><span class="nav-number">1.1.7.</span> <span class="nav-text">7. 清除行列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E7%BF%BB%E8%BD%AC%E5%AD%90%E4%B8%B2"><span class="nav-number">1.1.8.</span> <span class="nav-text">8. 翻转子串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E9%93%BE%E8%A1%A8"><span class="nav-number">1.2.</span> <span class="nav-text">二、链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. 链表中倒数第 k 个结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%AE%BF%E9%97%AE%E5%8D%95%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%88%A0%E9%99%A4"><span class="nav-number">1.2.2.</span> <span class="nav-text">2. 访问单个节点的删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%93%BE%E8%A1%A8%E5%88%86%E5%89%B2"><span class="nav-number">1.2.3.</span> <span class="nav-text">3. 链表分割</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%93%BE%E5%BC%8FA-B"><span class="nav-number">1.2.4.</span> <span class="nav-text">4. 链式A+B</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="nav-number">1.2.5.</span> <span class="nav-text">5. 回文链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-number">1.3.</span> <span class="nav-text">三、栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E9%9B%86%E5%90%88%E6%A0%88"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. 集合栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. 用两个栈实现队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8F%8C%E6%A0%88%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.3.</span> <span class="nav-text">3. 双栈排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%8C%AB%E7%8B%97%E6%94%B6%E5%AE%B9%E6%89%80"><span class="nav-number">1.3.4.</span> <span class="nav-text">4. 猫狗收容所</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%A0%91%E4%B8%8E%E5%9B%BE"><span class="nav-number">1.4.</span> <span class="nav-text">四、树与图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B9%B3%E8%A1%A1%E6%A3%80%E6%9F%A5"><span class="nav-number">1.4.1.</span> <span class="nav-text">1. 二叉树平衡检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%9C%89%E5%90%91%E8%B7%AF%E5%BE%84%E6%A3%80%E6%9F%A5"><span class="nav-number">1.4.2.</span> <span class="nav-text">2. 有向路径检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%AB%98%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84-BST"><span class="nav-number">1.4.3.</span> <span class="nav-text">3. 高度最小的 BST</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%A0%91%E8%BE%93%E5%87%BA%E5%8D%95%E5%B1%82%E7%BB%93%E7%82%B9"><span class="nav-number">1.4.4.</span> <span class="nav-text">4. 树输出单层结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E4%B8%BABST"><span class="nav-number">1.4.5.</span> <span class="nav-text">5. 检查是否为BST</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%AF%BB%E6%89%BE%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-number">1.4.6.</span> <span class="nav-text">6. 寻找下一个结点</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lumen</p>
  <div class="site-description" itemprop="description">Learn</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lumen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
