{"posts":[{"title":"Laravel 常见问题汇总","text":"前言作为一个 Laravel 开发者，在部署 Laravel 项目的时候总是会遇到这样那样奇怪的问题，每次遇到都要去 Google，实在是有点麻烦，就想自己整理一篇文章来记录这些常见的问题。 常见问题一：Specified key was too long 在开发 Laravel 的项目时，有时我们需要对数据库进行迁移，可是当我们在别的环境下跑 php artisan migrate 的时候经常会出现以下报错： 12345[Illuminate\\Database\\QueryException]SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long; max key length is 767 bytes (SQL: alter table users add unique users_email_unique (email))[PDOException]SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long; max key length is 767 bytes 这时候我们把下面的代码添加到 AppServiceProvider.php 12345use Illuminate\\Support\\Facades\\Schema;public function boot(){ Schema::defaultStringLength(191);} 常见问题二： This cache store does not support tagging有时候我们在项目跑的好好的，突然使用 php artisan migrate 就会出现这个错误。 准确的说，这不是一个bug，详情可以参考 这里，这是由于使用了 entrust 权限管理包导致，解决的话只需要修改 .env 文件，把 CACHE_DRIVER 改成 array 就可以啦。 常见问题三：The only supported ciphers are xxx and xxx with the correct key lengths这时候先确认你的 .env 文件是否存在，如果没有则创建，如果 .env 文件已经存在，则跑 php artisan key:generate 命令即可 常见问题四：使用 Laravel-passport 后 token 失效 注意使用反seeder导出数据库 如果发现线上服务器跑 migrate refresh 后又需要重新请求 token，则查看 .env 文件里 **APP_KEY **是否与本地一致 常见问题五：composer update出现 此时尝试一下 1composer clear-cache 常见问题六：Laravel的throttle中间件失效之前使用了zizaco/entrust（一个基于角色的权限管理包），其中把 .env 中的CACHE_DRIVER=file 改为了 CACHE_DRIVER=array。所以问题出现了。Laravel支持多种cache驱动，File, Array, Db, Redis等，但是throttle 好像使用File类型的驱动才有效。 修改 vendor/illuminate/cache/RateLimiter.php 文件 12345public function __construct(Cache $cache) { $this-&gt;cache = $cache; $this-&gt;cache = app('cache')-&gt;driver('file');//加上这行 }","link":"/2017/08/06/Laravel%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"},{"title":"Laravel 自带SMTP配置邮件服务","text":"开启邮箱服务 要使用邮箱服务就必须开启邮箱的 POP3 服务和 SMTP 服务，本教程演示 QQ邮箱的配置 登录你的 QQ邮箱，来到 设置-&gt;账户，开启下图中的服务 记录下生成的授权码！记录下生成的授权码！记录下生成的授权码！重要的事情说三遍！ 配置 修改 .env 文件，复制以下内容进去 123456MAIL_DRIVER=&quot;smtp&quot; //邮件发送驱动MAIL_HOST=&quot;smtp.qq.com&quot; //邮箱所在主机，比如网易邮箱是 smpt.163.comMAIL_PORT=25 //邮箱发送服务端口号，比如一般默认值是25，但如果设置SMTP使用SSL加密，该值为465MAIL_USERNAME=123456@qq.com //邮箱账号MAIL_PASSWORD=abcdefg //刚刚生成的授权码MAIL_ENCRYPTION=tls //加密类型，可以设置为null表示不使用任何加密，也可以设置为tls或ssl 修改 config/mail.php 文件 1234'from' =&gt; [ 'address' =&gt; '123456@qq.com', //用来发送邮件的邮箱 'name' =&gt; '', //发送邮件使用的用户名], 创建邮件模板在 resources/emails 创建一个模板文件 test.blade.php，并复制以下内容进去 1{{ $data['test1'] }} 这是测试 {{ $data['test2'] }}。 发送邮件 在 app/helpers.php 添加以下内容 1234function sendMail($email,$data,$view){ Mail::send('emails.'.$view,['data'=&gt;$data],function($message)use($email){ $message-&gt;to($email)-&gt;subject('【这是邮件标题】');; }); 在你需要调用发送邮件的方法的地方添加以下代码 1234567$email = '123456@qq.com'; //接受邮件的邮箱$tempData = [ 'test1' =&gt; 'hello', //邮件模板变量，自定 'test2' =&gt; 'world',];$view = 'test'; //要使用的模板，比如这里的是刚刚创建的模板 test.blade.phpsendMail($email,$tempData,$view); 邮件还支持 延时发送，添加附件，添加图片 的功能，这里就不展开了，详情可以参考官方文档 文档 laravel 邮件发送 官方文档：http://d.laravel-china.org/docs/5.3/mail","link":"/2017/08/06/Laravel%20%E9%85%8D%E7%BD%AE%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1/"},{"title":"PHP 单元测试","text":"PHPUnit 中的测试函数命名注意函数上方有 注释， 函数名使用下划线，相比于 驼峰法 的 PSR-2 规范，测试中函数可读性比较重要 1234/** @test */public function it_fetches_trending_articles(){} 测试数据库配置我们尽量不使用本来的数据库，另外配置一个测试的数据库 123456//在 config/database.php 新增以下内容'sqlite_test' =&gt; [ 'driver' =&gt; 'sqlite', 'database' =&gt; env('DB_DATABASE', database_path('sqlite_test.sqlite')), 'prefix' =&gt; '', ], 1php artisan migrate --database=sqlite_test tinkerlaravel-test php artisan tinkerPsy Shell v0.8.6 (PHP 7.1.2-3+deb.sury.org~xenial+1 — cli) by Justin Hileman DB::connection(‘sqlite_test’)-&gt;table(‘teams’)-&gt;truncate()=&gt; null","link":"/2017/05/17/PHP%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"title":"Laravel-sms + 阿里大鱼 配置定时发送短信服务","text":"安装 引入依赖 1composer require toplan/laravel-sms:~2.6 参数配置 在config/app.php文件中providers数组里加入： 12Toplan\\PhpSms\\PhpSmsServiceProvider::class,Toplan\\Sms\\SmsManagerServiceProvider::class, 在config/app.php文件中的aliases数组里加入： 12'PhpSms' =&gt; Toplan\\PhpSms\\Facades\\Sms::class,'SmsManager' =&gt; Toplan\\Sms\\Facades\\SmsManager::class, 配置 修改 config/phpsms.php 123scheme' =&gt; [ 'Alidayu',//配置代理器为阿里大鱼], 修改 app/helpers.php ，复制以下内容进去 123456function sendMessage($mobile,$template_id,$tempData){ $templates = [ 'Alidayu' =&gt; $template_id//模板id ]; Toplan\\PhpSms\\Sms::make()-&gt;to($mobile)-&gt;template($templates)-&gt;data($tempData)-&gt;send();} Artisan 命令行 生成命令 1php artisan make:command SendMessage 配置命令 刚才生成的 Artisan 命令行 文件在 app/Console/Commands 目录，我们修改目录下刚刚生成的的 SendMessage.php 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phpnamespace App\\Console\\Commands;use Illuminate\\Console\\Command;class SendMessage extends Command{ /** * The name and signature of the console command. * * @var string */ protected $signature = 'message:send';//命令的格式，比如这里命令就是 php artisan message:send /** * The console command description. * * @var string */ protected $description = 'Send message to user';//命令的描述 /** * Create a new command instance. * * @return void */ public function __construct() { parent::__construct(); } /** * Execute the console command. * * @return mixed */ public function handle() { //这里处理你的业务逻辑 $mobile = 11111111111;//要发送的手机号 template_id ＝ 111111;//你的阿里大鱼模板id $tempData = [ 'name' =&gt; '123',//模板变量自定 ]; sendMessage($mobile,$template_id,$tempData); }} 注册命令 修改 app/Console/Kernel.php 文件，添加以下内容 123protected $commands = [ Commands\\SendMessage::class,]; 确认命令正确生成和配置 使用 php artisan list 命令，如果能看到 php artisan message:send 说明配置成功 定时任务在你的服务器（linux）使用 crontab -e，添加以下内容 1* * 1 * * cd 你的项目根目录 &amp;&amp; php artisan message:send 这是每天执行一次的定时任务，如果你还不明白定时任务怎么使用，请查看 定时任务用法例子 Debug为了方便我们排查错误，我们在数据库创建一个日志表 laravel-sms 创建 migration 文件 1php artisan make:migration create_sms_table --create 复制以下内容进去 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?phpuse Illuminate\\Database\\Migrations\\Migration;use Illuminate\\Database\\Schema\\Blueprint;class CreateSmsTable extends Migration{ /** * Run the migrations. * * @return void */ public function up() { Schema::create('laravel_sms', function (Blueprint $table) { $table-&gt;increments('id'); //to:用于存储手机号 $table-&gt;string('to')-&gt;default(''); //temp_id:存储模板标记，用于存储任何第三方服务商提供的短信模板标记/id $table-&gt;string('temp_id')-&gt;default(''); //data:模板短信的模板数据，建议json格式 $table-&gt;string('data')-&gt;default(''); //content:内容 $table-&gt;string('content')-&gt;default(''); //voice_code:语言验证码code $table-&gt;string('voice_code')-&gt;default(''); //发送失败次数 $table-&gt;mediumInteger('fail_times')-&gt;default(0); //最后一次发送失败时间 $table-&gt;integer('last_fail_time')-&gt;unsigned()-&gt;default(0); //发送成功时的时间 $table-&gt;integer('sent_time')-&gt;unsigned()-&gt;default(0); //代理器使用日志，记录每个代理器的发送状态，可用于排错 $table-&gt;text('result_info')-&gt;nullable(); $table-&gt;timestamps(); $table-&gt;softDeletes(); $table-&gt;engine = 'InnoDB'; //说明 //1：temp_id和data用于发送模板短信。 //2：content用于直接发送短信内容，不使用模板。 //3：voice_code用于存储语言验证码code。 }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::dropIfExists('laravel_sms'); }} 迁移数据库 php artisan migrate 这样我们就可以很方便的查看日志来排查错误啦 其他 laravel-sms 官方文档：https://github.com/toplan/laravel-smsphp-sms 官方文档：https://github.com/toplan/phpsmsArtisan 命令行官方文档：http://d.laravel-china.org/docs/5.3/artisan#registering-commands","link":"/2017/05/17/Laravel-sms%20%E9%85%8D%E7%BD%AE%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1/"},{"title":"Selenium自动化测试工具","text":"一、介绍Selenium 是一款用于Web应用程序测试的工具 ，支持绝大部分主流浏览器，包括 IE（7, 8, 9, 10, 11），Mozilla Firefox，Safari，Google Chrome，Opera等。 但是，Selenium 不仅仅可以用作自动化测试，还有很多种玩法，比如 Python 的爬虫，实现某宝商品的秒杀，甚至是页游外挂脚本，只要是基于浏览器操作，只有你想不到，没有 Selenium 做不到，就是这么强大！ 二、安装 python2/3 pip 安装 Selenium 1pip install selenium 安装浏览器驱动 selenium 支持各种浏览器，仅需下载自己常用浏览器对应的驱动即可。我使用的是 chrome 浏览器，驱动下载可以参考 传送门，Windows 系统需要额外注意，下载完成后要把解压出来的文件加入系统环境变量 PATH 中。 测试 执行下面的 python 语句 1234567from selenium import webdriverfrom selenium.webdriver.common.keys import Keysbrowser = webdriver.Chrome()browser.get('https://www.baidu.com')browser.find_element_by_id('kw').send_keys('66666666')browser.find_element_by_id('kw').send_keys(Keys.ENTER) 看到下图说明安装成功！ 三、一般操作 页面元素定位 通过 id 定位 1browser.find_element_by_id(&quot;&quot;) 通过 name 定位 1browser.find_element_by_name(&quot;&quot;) 通过 class name 定位 1browser.find_element_by_class_name(&quot;&quot;) 通过 tag name 定位 1browser.find_element_by_tag_name(&quot;&quot;) 通过 xpath 定位 1browser.find_element_by_xpath(&quot;&quot;) 通过 css 定位 (可查找复合类，父子，兄弟，相邻节点) 123456browser.find_element_by_css_selector(&quot;#kw&quot;)browser.find_element_by_css_selector(&quot;[name=wd]&quot;)browser.find_element_by_css_selector(&quot;.s_ipt&quot;)browser.find_element_by_css_selector(&quot;html &gt; body &gt; form &gt; span &gt; input&quot;)browser.find_element_by_css_selector(&quot;span.soutu-btn&gt; input#kw&quot;)browser.find_element_by_css_selector(&quot;form#form &gt; span &gt; input&quot;) 通过link text定位 1browser.find_element_by_link_text(&quot;新闻&quot;) 鼠标事件 引入提供鼠标操作的 ActionChains 类 1from selenium.webdriver import ActionChains 调用 ActionChains()类， 将浏览器驱动 driver 作为参数传入 1ActionChains(browser) 鼠标悬停 1move_to_element(above) 右击 1context_click() 执行所有 ActionChains 中存储的行为， 可以理解成是对整个操作的提交动作。比如悬停后要执行 perform() 才会生效 1perform() 键盘事件 引入 Keys 类 1from selenium.webdriver.common.keys import Keys 常用按键 123456789101112131415161718192021send_keys(Keys.BACK_SPACE) 删除键（BackSpace）send_keys(Keys.SPACE) 空格键(Space)send_keys(Keys.TAB) 制表键(Tab)send_keys(Keys.ESCAPE) 回退键（Esc）send_keys(Keys.ENTER) 回车键（Enter）send_keys(Keys.CONTROL,‘a’) 全选（Ctrl+A）send_keys(Keys.CONTROL,‘c’) 复制（Ctrl+C）send_keys(Keys.CONTROL,‘x’) 剪切（Ctrl+X）send_keys(Keys.CONTROL,‘v’) 粘贴（Ctrl+V）send_keys(Keys.F1) 键盘 F1send_keys(Keys.F12) 键盘 F12 窗口切换 1234567driver.switch_to_window(&quot;windowName&quot;)# 获取所有打开窗口句柄all_handles = driver.window_handles# 获取当前窗口句柄current_windows = driver.current_window_handle 设置元素等待 显式等待 123456789# 导入需要的库from selenium.webdriver.support.wait import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.common.by import By# 0.5秒轮询一次，直到定位到元素继续往后执行，10秒后没定位到则抛出异常search_bar = WebDriverWait(browser, 10, 0.5).until( EC.presence_of_element_located((By.CLASS_NAME , &quot;nav_text&quot;)) ) 隐式等待 123browser.implicitly_wait(30) # 隐性等待，最长等30秒注意：1. 隐式等待可以和显式等待共用，等待时间取两者中最大值 2. 隐式等待是全局生效，等当前页面元素全部加载完成后才往后执行 强制等待 123# 强制等待一秒import timetime.sleep(1) cookie操作 123456789get_cookies()： 获得所有cookie信息。get_cookie(name)： 返回字典的key为“name”的cookie信息。add_cookie(cookie_dict) ： 添加cookie。“cookie_dict”指字典对象，必须有name 和value 值。delete_cookie(name,optionsString)：删除cookie信息。“name”是要删除的cookie的名称，“optionsString”是该cookie的选项，目前支持的选项包括“路径”，“域”。delete_all_cookies()： 删除所有cookie信息。 四、示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from selenium import webdriverfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.common.action_chains import ActionChainsimport timebrowser = webdriver.Chrome()# 隐式等待browser.implicitly_wait(10)browser.set_window_size(1680,950)browser.get('https://200.200.158.204')time.sleep(1)c1 = { 'value': '967u0bb1ul9vhvfpfa5pplukr1', 'expiry': 2163204317, 'path': '/', 'name': 'PHPSESSID', 'httpOnly': True, 'secure': True, 'domain': '200.200.158.204' }browser.add_cookie(c1)c2 = { 'value': 'lv0fh188vmmavgakce9mha97g5', 'expiry': 2163204317, 'path': '/', 'name': 'sf_session', 'httpOnly': True, 'secure': False, 'domain': '200.200.158.204' }browser.add_cookie(c2)browser.refresh();search_bar = WebDriverWait(browser, 10, 0.5).until( EC.presence_of_element_located((By.CLASS_NAME , &quot;nav_text&quot;)) )search_bar.clear()search_bar.send_keys(&quot;账号安全&quot;)time.sleep(2)search_bar.send_keys(Keys.ENTER)browser.find_element_by_name(&quot;time_range&quot;).click()browser.find_element_by_css_selector(&quot;div.x-combo-list-inner &gt; div:nth-child(3)&quot;).click()time.sleep(10)browser.close()","link":"/2017/08/06/Selenium%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"},{"title":"craking the code interview 第五版 C++实现","text":"[TOC] 面试考题本篇为学习笔记，题目出自 craking the code interview，中文译名 程序员面试经典（第五版），用 C/C++ 实现 一. 字符串与数组1. 确定字符互异 题目描述： 请实现一个算法，确定一个字符串的所有字符是否全都不同。这里我们要求不允许使用额外的存储结构。 给定一个string iniString，请返回一个bool值,True代表所有字符全都不同，False代表存在相同的字符。保证字符串中的字符为ASCII字符。字符串的长度小于等于3000。 测试样例： 12&quot;aeiou&quot; 返回：True&quot;BarackObama&quot; 返回：False 较差的实现方式： 1234567891011121314151617181920class Different {public: bool checkDifferent(string iniString) { // write code here if(iniString.length() == 0 || iniString.length() &gt; 256){ return false; } for(int i = 0;i &lt; iniString.length() - 1;i++){ //长度-1是因为最后一个元素不需要比较，前面已经比较过了 for(int j = i + 1;j &lt; iniString.length();j++){ if(iniString[i] == iniString[j]){ return false; } } } return true; }}; 较优的实现方式： 123456789101112131415161718192021class Different {public: bool checkDifferent(string iniString) { // write code here if(iniString.length() == 0 || iniString.length() &gt; 256){ return false; } bool b[256] = {true};//C++里面要先赋值，否则会提示数组越界 for(int i = 0;i &lt; iniString.length();i++){ int c = iniString[i]; if(b[c] == true){ return false; } b[c] = true;//出现过一次的数设为true，第二次一旦出现则返回false } return true; }}; 2. 原串翻转 题目描述： 请实现一个算法，在不使用额外数据结构和储存空间的情况下，翻转一个给定的字符串(可以使用单个过程变量)。 给定一个string iniString，请返回一个string，为翻转后的字符串。保证字符串的长度小于等于5000。 测试样例： 12&quot;This is nowcoder&quot;返回：&quot;redocwon si sihT&quot; 1234567891011121314151617class Reverse {public: string reverseString(string iniString) { // write code here int start = 0; int end = iniString.length() - 1; char tmp; while(start &lt; end){ tmp = iniString[start]; iniString[start++] = iniString[end]; iniString[end--] = tmp; } return iniString; }}; 3. 确定两串乱序同构 题目描述 给定两个字符串，请编写程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。这里规定大小写为不同字符，且考虑字符串重点空格。 给定一个string stringA和一个string stringB，请返回一个bool，代表两串是否重新排列后可相同。保证两串的长度都小于等于5000。 测试样例： 1234&quot;This is nowcoder&quot;,&quot;is This nowcoder&quot;返回：true&quot;Here you are&quot;,&quot;Are you here&quot;返回：false 12345678910111213141516class Same {public: bool checkSam(string stringA, string stringB) { // write code here if(stringA.length() != stringB.length()){ return false; } sort(stringA.begin(),stringA.end()); sort(stringB.begin(),stringB.end()); if (stringA == stringB) return true; return false; }}; 4. 空格替换 题目描述 请编写一个方法，将字符串中的空格全部替换为“%20”。假定该字符串有足够的空间存放新增的字符，并且知道字符串的真实长度(小于等于1000)，同时保证字符串由大小写的英文字母组成。 给定一个string iniString 为原始的串，以及串的长度 int len, 返回替换后的string。 测试样例： 1234&quot;Mr John Smith”,13返回：&quot;Mr%20John%20Smith&quot;”Hello World”,12返回：”Hello%20%20World” 12345678910111213141516class Replacement {public: string replaceSpace(string iniString, int length) { // write code here string str=&quot;&quot;; for(int i=0; i&lt;length; i++){ if(iniString[i]==' '){ str += string(&quot;%20&quot;); } else{ str += iniString[i]; } } return str; }}; 5. 基本字符串压缩 题目描述 利用字符重复出现的次数，编写一个方法，实现基本的字符串压缩功能。比如，字符串“aabcccccaaa”经压缩会变成“a2b1c5a3”。若压缩后的字符串没有变短，则返回原先的字符串。 给定一个string iniString为待压缩的串(长度小于等于10000)，保证串内字符均由大小写英文字母组成，返回一个string，为所求的压缩后或未变化的串。 测试样例 1234&quot;aabcccccaaa&quot;返回：&quot;a2b1c5a3&quot;&quot;welcometonowcoderrrrr&quot;返回：&quot;welcometonowcoderrrrr&quot; 12345678910111213141516171819202122232425262728class Zipper {public: string zipString(string iniString) { // write code here string myStr; int count = 1,i; char last = iniString[0];//最后一个不同的字符 for(i = 1;i &lt; iniString.length();i++){ if(last == iniString[i]){ count++; }else{ myStr += last + to_string(count); last = iniString[i]; count = 1; } } string res = myStr + last + to_string(count); if(res.length() &gt;= iniString.length()){ return iniString; } return res; }}; 6. 像素翻转 题目描述 有一副由NxN矩阵表示的图像，这里每个像素用一个int表示，请编写一个算法，在不占用额外内存空间的情况下(即不使用缓存矩阵)，将图像顺时针旋转90度。 给定一个NxN的矩阵，和矩阵的阶数N,请返回旋转后的NxN矩阵,保证N小于等于500，图像元素小于等于256。 测试样例： 12[[1,2,3],[4,5,6],[7,8,9]],3返回：[[7,4,1],[8,5,2],[9,6,3]] 7. 清除行列 题目描述 请编写一个算法，若N阶方阵中某个元素为0，则将其所在的行与列清零。 给定一个N阶方阵int[][](C++中为vector&gt;)mat和矩阵的阶数n，请返回完成操作后的**int[][]**方阵(C++中为vector&gt;)，保证n小于等于300，矩阵中的元素为int范围内。 测试样例： 12[[1,2,3],[0,1,2],[0,0,1]]返回：[[0,0,3],[0,0,0],[0,0,0]] 123456789101112131415161718192021222324252627class Clearer {public: vector&lt;vector&lt;int&gt; &gt; clearZero(vector&lt;vector&lt;int&gt; &gt; mat, int n) { // write code here vector&lt;bool&gt; row(n,false); vector&lt;bool&gt; column(n,false); for(int i =0;i &lt; n;i++){ for(int j = 0;j &lt; n;j++){ if(mat[i][j] == 0){ row[i] = true; column[j] = true; } } } for(int i = 0;i &lt; n;i++){ for(int j = 0;j &lt; n;j++){ if(row[i] || column[j]){ mat[i][j] = 0; } } } return mat; }}; 8. 翻转子串 题目描述 假定我们都知道非常高效的算法来检查一个单词是否为其他字符串的子串。请将这个算法编写成一个函数，给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成，要求只能调用一次检查子串的函数。 给定两个字符串s1,s2,请返回bool值代表s2是否由s1旋转而成。字符串中字符为英文字母和空格，区分大小写，字符串长度小于等于1000。 测试样例： 1234&quot;Hello world&quot;,&quot;worldhello &quot;返回：false&quot;waterbottle&quot;,&quot;erbottlewat&quot;返回：true 1234567891011121314151617class ReverseEqual {public: bool checkReverseEqual(string s1, string s2) { // write code here if(s1.length() != s2.length()){ return false; } string s1s1 = s1 + s1; if(s1s1.find(s2) == -1){ //原理:s2(旋转后的串) 一定是 s1(原串) ＋ s1 的子串,否则 s2 不能由 s1 旋转而来 return false; } return true; }}; 二、链表1. 链表中倒数第 k 个结点 题目描述 输入一个链表，输出该链表中倒数第k个结点。 123456789101112131415161718192021222324252627282930313233343536/*struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { }};*/class Solution {public: ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) { if(pListHead == NULL){ return NULL; } //双指针 ListNode *p1 = pListHead; ListNode *p2 = pListHead; for(int i = 1;i &lt;= k;i++){ //p2先向前移动k位 if(p2 == NULL){ return NULL; } p2 = p2-&gt;next; } while(p2 != NULL){ //p1 p2同时移动，当p2到达 p1 = p1-&gt;next; p2 = p2-&gt;next; } return p1; }}; 2. 访问单个节点的删除 题目描述 实现一个算法，删除单向链表中间的某个结点，假定你只能访问该结点。 给定待删除的节点，请执行删除操作，若该节点为尾节点，返回false，否则返回true 1234567891011121314151617181920212223/*struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) {}};*/class Remove {public: bool removeNode(ListNode* pNode) { // write code here if(!pNode || !pNode-&gt;next){ return false; } ListNode* p = pNode-&gt;next; pNode-&gt;val = p-&gt;val; pNode-&gt;next = p-&gt;next; return true; }}; 3. 链表分割 题目描述 编写代码，以给定值x为基准将链表分割成两部分，所有小于x的结点排在大于或等于x的结点之前 给定一个链表的头指针 ListNode* pHead，请返回重新排列后的链表的头指针。注意：分割以后保持原来的数据顺序不变。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/*struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) {}};*/class Partition {public: ListNode* partition(ListNode* pHead, int x) { // write code here ListNode* temp1 = nullptr; ListNode* head1 = nullptr; ListNode* head2 = nullptr; ListNode* temp2 = nullptr; while(pHead != nullptr){ ListNode* node = pHead-&gt;next;//此处保留下一个节点，因为要赋值的节点的next要设置为null pHead-&gt;next = nullptr;//将next为空，这样才能只赋值一个节点 if(pHead-&gt;val &lt; x){ if(head1 == nullptr){ head1 = pHead; temp1 = head1; }else{ temp1-&gt;next = pHead; temp1 = temp1-&gt;next; } }else{ if(head2 == nullptr){ head2 = pHead; temp2 = head2; }else{ temp2-&gt;next = pHead; temp2 = temp2-&gt;next; } } pHead = node; } //此处要判断是否为空 if(head1 == nullptr){ return head2; } temp1-&gt;next = head2; return head1; }}; 4. 链式A+B 题目描述 有两个用链表表示的整数，每个结点包含一个数位。这些数位是反向存放的，也就是个位排在链表的首部。编写函数对这两个整数求和，并用链表形式返回结果。 给定两个链表ListNode* A，ListNode* B，请返回A+B的结果(ListNode*)。 测试样例： 12{1,2,3},{3,2,1}返回：{4,4,4} 12345678910111213141516171819202122232425262728293031323334353637383940414243/*struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) {}};*/class Plus {public: ListNode* plusAB(ListNode* a, ListNode* b) { // write code here if(a == nullptr || b == nullptr){ return false; } ListNode* head = new ListNode(-1);//创建一个空链表 ListNode* p = head;//创建p指针指向head ListNode* pa = a; ListNode* pb = b; ListNode* node = nullptr;//声明存放结果节点的变量，初值为空 int c = 0,sum,val1,val2;//声明 进位、和、值1、值2 while(pa != nullptr || pb != nullptr || c != 0){ val1 = pa == nullptr ? 0 : pa-&gt;val; val2 = pb == nullptr ? 0 : pb-&gt;val; sum = val1 + val2 + c; c = sum / 10; node = new ListNode(sum%10);//创建链表，值为当前位结果值 //尾插法 p-&gt;next = node;//给head创建后继节点 p = node;//p移动到node pa = pa == nullptr ? nullptr : pa-&gt;next; pb = pb == nullptr ? nullptr : pb-&gt;next; } return head-&gt;next; }}; 5. 回文链表 题目描述 请编写一个函数，检查链表是否为回文。 给定一个链表ListNode* pHead，请返回一个bool，代表链表是否为回文。 测试样例： 1234{1,2,3,2,1}返回：true{1,2,3,2,3}返回：false 反转链表并比较 1234567891011121314151617181920212223242526/*struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) {}};*/class Palindrome {public: bool isPalindrome(ListNode* pHead) { // write code here if(pHead == nullptr || pHead-&gt;next == nullptr){ return true; } string s; while(pHead){ s += to_string(pHead-&gt;val); pHead = pHead-&gt;next; } string s2 = s; reverse(s2.begin(),s2.end()); return s2 == s; }}; 迭代法：利用快慢指针，找到中间节点；将慢指针节点的值压入栈，到达中间节点后，依次出栈与后续节点的值比较。特别注意长度奇偶数。 123456789101112131415161718192021222324252627282930313233343536373839/*struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) {}};*/class Palindrome {public: bool isPalindrome(ListNode* pHead) { // write code here if(pHead == nullptr || pHead-&gt;next == nullptr){ return true; } stack&lt;int&gt; s;//定义一个栈 ListNode* fast = pHead;//快指针 ListNode* slow = pHead;//慢指针 while(fast &amp;&amp; fast-&gt;next){ s.push(slow-&gt;val);//入栈 slow = slow-&gt;next; fast = fast-&gt;next-&gt;next;//快指针用慢指针两倍速度移动 } if(fast){ //节点个数是奇数 slow = slow-&gt;next;//跳过中间节点 } while(slow){ if(s.top() != slow-&gt;val){ return false; } s.pop(); slow = slow-&gt;next; } return true; }}; 三、栈和队列1. 集合栈 题目描述 请实现一种数据结构SetOfStacks，由多个栈组成，其中每个栈的大小为size，当前一个栈填满时，新建一个栈。该数据结构应支持与普通栈相同的push和pop操作。 给定一个操作序列int[][2] ope(C++为vector&lt;vector&gt;)，每个操作的第一个数代表操作类型，若为1，则为push操作，后一个数为应push的数字；若为2，则为pop操作，后一个数无意义。请返回一个int[]，为完成所有操作后的SetOfStacks，顺序应为从下到上，默认初始的SetOfStacks为空。保证数据合法。 123456789101112131415161718192021222324252627282930313233343536373839class SetOfStacks {public: vector&lt;vector&lt;int&gt; &gt; setOfStacks(vector&lt;vector&lt;int&gt; &gt; ope, int size) { // write code here vector&lt;vector&lt;int&gt; &gt; stack;//定义结果栈 vector&lt;int&gt; temp;//用来置换的栈 for(int i = 0;i &lt; ope.size();i++){ if(ope[i][0] == 1){ //入栈 if(temp.size() == size){ //置换的栈满，清空栈再入栈 stack.push_back(temp); temp.clear(); temp.push_back(ope[i][1]); }else{ //栈未满，直接入栈 temp.push_back(ope[i][1]); } }else if(ope[i][0] == 2){ //出栈 if(temp.empty()){ //当前栈为空，弹出stack总栈栈顶并赋予temp，然后temp再弹出栈顶元素（相当于回滚一个入栈操作） temp = stack[stack.size()-1]; stack.pop_back(); temp.pop_back(); }else{ //当前栈不为空，直接出栈 temp.pop_back(); } } } if(!temp.empty()){ //有残留元素未入栈（未达到size），现在入总栈 stack.push_back(temp); } return stack; }}; 2. 用两个栈实现队列 题目描述 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 1234567891011121314151617181920212223242526272829class Solution{public: void push(int node) { //入列 stack1.push(node);//将最新元素压入栈1，栈1始终是比较新的元素 } int pop() { //出列 int tmp; if(stack2.empty()){ //旧栈（栈2）为空，则把栈1反转后压入栈2，在栈2出栈，清空栈1 while(!stack1.empty()){ tmp = stack1.top(); stack2.push(tmp); stack1.pop(); } } //旧栈不为空，可直接出栈 tmp = stack2.top(); stack2.pop(); return tmp; }private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2;}; 3. 双栈排序 题目描述 请编写一个程序，按升序对栈进行排序（即最大元素位于栈顶），要求最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。 给定一个int[] numbers(C++中为vector&amp;ltint&gt;)，其中第一个元素为栈顶，请返回排序后的栈。请注意这是一个栈，意味着排序过程中你只能访问到第一个元素。 测试样例： 12[1,2,3,4,5]返回：[5,4,3,2,1] 1234567891011121314151617181920class TwoStacks {public: vector&lt;int&gt; twoStacksSort(vector&lt;int&gt; numbers) { // write code here vector&lt;int&gt; res; int tmp; while(!numbers.empty()){ tmp = numbers.back();//拿到最先进来的元素(数组的最后一个元素) numbers.pop_back(); while(!res.empty() &amp;&amp; res.back() &gt; tmp){ numbers.push_back(res.back()); res.pop_back(); } res.push_back(tmp); } reverse(res.begin(),res.end());//因为一直用的是数组，最后翻转成栈 return res; }}; 4. 猫狗收容所 题目描述 有家动物收容所只收留猫和狗，但有特殊的收养规则，收养人有两种收养方式，第一种为直接收养所有动物中最早进入收容所的，第二种为选择收养的动物类型（猫或狗），并收养该种动物中最早进入收容所的。 ​ 给定一个操作序列int[][2] ope(C++中为vector&lt;vector&gt;)代表所有事件。若第一个元素为1，则代表有动物进入收容所，第二个元素为动物的编号，正数代表狗，负数代表猫；若第一个元素为2，则代表有人收养动物，第二个元素若为0，则采取第一种收养方式，若为1，则指定收养狗，若为-1则指定收养猫。请按顺序返回收养的序列。若出现不合法的操作，即没有可以符合领养要求的动物，则将这次领养操作忽略。 测试样例： 12[[1,1],[1,-1],[2,0],[2,-1]]返回：[1,-1] 如果只维护一个队列，只需要取出队头的动物则可以，但如果指定要收养猫或者狗就要迭代访问整个队列，效率比较低 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class CatDogAsylum {public: vector&lt;int&gt; asylum(vector&lt;vector&lt;int&gt; &gt; ope) { // write code here vector&lt;int&gt; animals;//收容所动物数组 vector&lt;int&gt; res;//结果数组 for(int i = 0;i &lt; ope.size();i++){ if(ope[i][0] == 1){ //有动物进入收容所 animals.push_back(ope[i][1]);//狗就是正数，猫是负数 }else if(ope[i][0] == 2){ //有人收养动物 if(animals.empty()){ //收容所没有动物 continue; } if(ope[i][1] == 0){ //第一种收养方式 res.push_back(animals[0]); animals.erase(animals.begin());//删除动物 }else if(ope[i][1] == 1){ //收养狗 for(int j = 0;j &lt; animals.size();j++){ if(animals[j] &gt; 0){ //狗是正数 res.push_back(animals[j]); animals.erase(animals.begin() + j);//删除狗 break; } } }else if(ope[i][1] == -1){ //收养猫 for(int j = 0;j &lt; animals.size();j++){ if(animals[j] &lt; 0){ //猫是负数 res.push_back(animals[j]); animals.erase(animals.begin() + j);//删除猫 break; } } } } } return res; }}; 用两个队列，猫和狗各自一个队列来维护，用一个变量记录时间顺序，就可以返回最老的一只猫或狗 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class CatDogAsylum {public: vector&lt;int&gt; asylum(vector&lt;vector&lt;int&gt; &gt; ope) { // write code here queue&lt;int&gt; cats; queue&lt;int&gt; dogs; vector&lt;int&gt; res; int step = 0;//动物进入收容所的时间记录 int oldest; for(int i = 0;i &lt; ope.size();i++){ if(ope[i][0] == 1){ //有动物进入收容所 if(ope[i][1] &gt; 0){ //狗 dogs.push(step++); dogs.push(ope[i][1]); }else if(ope[i][1] &lt; 0){ //猫 cats.push(step++); cats.push(ope[i][1]); } }else if(ope[i][0] == 2){ //有人收养动物 if(cats.empty() &amp;&amp; dogs.empty()){ //收容所没有动物 continue; } if(ope[i][1] == 0){ //第一种收养方式 if(!cats.empty() &amp;&amp; dogs.empty()){ //有猫无狗 oldest = -1; }else if(cats.empty() &amp;&amp; !dogs.empty()){ //有狗无猫 oldest = 1; }else if(!cats.empty() &amp;&amp; !dogs.empty()){ //有狗也有猫 oldest = cats.front() &lt; dogs.front() ? -1 : 1; } if(oldest == 1){ dogs.pop();//删除step res.push_back(dogs.front()); dogs.pop();//删除狗编号 }else{ cats.pop(); res.push_back(cats.front()); cats.pop(); } }else if(ope[i][1] == 1 &amp;&amp; !dogs.empty()){ //收养狗 dogs.pop();//删除step res.push_back(dogs.front()); dogs.pop();//删除狗编号 }else if(ope[i][1] == -1 &amp;&amp; !cats.empty()){ //收养猫 cats.pop(); res.push_back(cats.front()); cats.pop(); } } } return res; }}; 四、树与图1. 二叉树平衡检查 题目描述 实现一个函数，检查二叉树是否平衡，平衡的定义如下，对于树中的任意一个结点，其两颗子树的高度差不超过1。 给定指向树根结点的指针TreeNode* root，请返回一个bool，代表这棵树是否平衡。 方法一：首先想到的是如何求一个树的高度，求一个树的高度很简单，递归求解，每次求出左右子树的最大高度再加1便是父节点的高度，这样递归下去，便可以求出任何一颗树的高度 12345678910111213141516171819202122232425262728293031323334/*struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { }};*/class Balance {public: bool isBalance(TreeNode* root) { // write code here if(root == nullptr){ return true;//递归完所有结点了，并无不平衡 } if(abs(getHeight(root-&gt;left) - getHeight(root-&gt;right)) &gt; 1){ return false;//abs是求两棵树高度差的绝对值 } return isBalance(root-&gt;left) &amp;&amp; isBalance(root-&gt;right);//递归判断左右子树是否“同时”平衡 } int getHeight(TreeNode* root){ if(root == nullptr){ return 0;//递归到最后的子结点，高度是0 } int left_height = getHeight(root-&gt;left); int right_height = getHeight(root-&gt;right); return left_height &gt; right_height ? left_height + 1 : right_height + 1;//＋1就是父结点高度 }}; 方法二：递归到最后的子结点，向上递归的时候，如果左右子树高度不平衡，返回－1，平衡则返回父结点的高度 1234567891011121314151617181920212223242526272829303132333435363738394041/*struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { }};*/class Balance {public: bool isBalance(TreeNode* root) { // write code here return checkHeight(root) != -1; } int checkHeight(TreeNode* root){ if(root == nullptr){ return 0; } //先检查左右子树是否平衡，从下往上判断，不平衡就返回-1，这样以免每次都从上计算到最底下 int left_height = checkHeight(root-&gt;left); if(left_height == -1){ return -1; } int right_height = checkHeight(root-&gt;right); if(right_height == -1){ return -1; } //再判断此节点是否平衡，平衡返回高度 if(abs(left_height - right_height) &gt; 1){ return -1; } return left_height &gt; right_height ? left_height + 1 : right_height + 1; }}; 2. 有向路径检查 题目描述 对于一个有向图，请实现一个算法，找出两点之间是否存在一条路径。 给定图中的两个结点的指针UndirectedGraphNode* a,UndirectedGraphNode* b(请不要在意数据类型，图是有向图),请返回一个bool，代表两点之间是否存在一条路径(a到b或b到a)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*struct UndirectedGraphNode { int label; vector&lt;struct UndirectedGraphNode *&gt; neighbors; UndirectedGraphNode(int x) : label(x) {}};*/class Path {public: bool checkPath(UndirectedGraphNode* a, UndirectedGraphNode* b) { // write code here return search(a,b) || search(b,a); } bool search(UndirectedGraphNode* a, UndirectedGraphNode* b){ if(a == b){ return true; } map&lt;UndirectedGraphNode*,bool&gt; m;//记录所有结点是否被访问过 queue&lt;UndirectedGraphNode*&gt; q;//邻居队列 UndirectedGraphNode* current; int i; q.push(a); while(!q.empty()){ current = q.front(); m[current] = true; for(i = 0;i &lt; current-&gt;neighbors.size();i++){ //遍历邻居 if(current-&gt;neighbors[i] == b){ //邻居就是b，找到路径 return true; }else if(current-&gt;neighbors[i] != NULL &amp;&amp; m[current-&gt;neighbors[i]] != true){ //当前这个邻居不为空，而且未被访问过 q.push(current-&gt;neighbors[i]); } } q.pop();//把当前访问过的邻居父结点弹出 } //遍历完所有邻居的邻居的邻居。。。 return false; }}; 3. 高度最小的 BST 题目描述 对于一个元素各不相同且按升序排列的有序序列，请编写一个算法，创建一棵高度最小的二叉查找树。 给定一个有序序列int[] vals,请返回创建的二叉查找树的高度。 思路：高度最小即理解为左右子树的结点数量越接近越好，也就是，根结点是数组中间，左半边是左子树，右半边是右子树，第一种方法是从根结点开始递归插入值到树中，构建二叉树，但是这种方法效率不高，每次插入都要遍历整棵树，因此采用第二种方法，传入数组的区间段。 如果是返回高度的话 12345678910111213141516class MinimalBST {public: int buildMinimalBST(vector&lt;int&gt; vals) { // write code here return build(vals,0,vals.size() - 1); } int build(vector&lt;int&gt; vals,int start,int end){ if(start &gt; end){ return 0;//遍历到叶子结点了 } int mid = (start + end) / 2; return max(build(vals,start,mid - 1),build(vals,mid + 1,end)) + 1; }}; 如果是构建二叉树 1234567891011121314151617181920212223242526class MinimalBST { class TreeNode{ int val; TreeNode* left = null; TreeNode* right = null; public TreeNode(int n){ this-&gt;val = n; } }public: int buildMinimalBST(vector&lt;int&gt; vals) { // write code here return build(vals,0,vals.size() - 1); } int build(vector&lt;int&gt; vals,int start,int end){ if(start &gt; end){ return null;//遍历到叶子结点了 } TreeNode* node = new TreeNode(vals[mid]); int mid = (start + end) / 2; node.left = build(vals,start, mid-1); node.right = build(vals,mid+1, end); return node; }}; 4. 树输出单层结点 题目描述 对于一棵二叉树，请设计一个算法，创建含有某一深度上所有结点的链表。 给定二叉树的根结点指针TreeNode* root，以及链表上结点的深度，请返回一个链表ListNode，代表该深度上所有结点的值，请按树上从左往右的顺序链接，保证深度不超过树的高度，树上结点的值为非负整数且不超过100000。 思路：有两种方法，第一种方法使用递归遍历整颗树，如果递归的当前结点是需要输出的那一层的结点，则把结点插入到链表中，最后返回链表即可。第二种方法，使用层次遍历，即广度优先遍历的方法，利用队列实现。 方法一：递归（深度优先） 12345678910111213141516171819202122232425262728293031323334353637383940/*struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { }};*//*struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) {}};*/class TreeLevel {public: ListNode* getTreeLevel(TreeNode* root, int dep) { // write code here ListNode* list = new ListNode(-1);//存放单层结点的链表 ListNode* listHead = list;//结果链表 insert(root,list,dep); return listHead-&gt;next; } void insert(TreeNode* root,ListNode* &amp;list,int dep) { if (root == nullptr || dep &lt;= 0){ return ; } if(dep == 1){ ListNode* temp = new ListNode(root-&gt;val); list-&gt;next = temp; list = list-&gt;next;//为什么要移动指针，因为下面要作为参数递归，每一次递归的当前指针指向的都是上一次递归指向的结点 return ; } insert(root-&gt;left,list,dep-1); insert(root-&gt;right,list,dep-1); }}; 方法二：层次遍历（广度优先），利用current变量记录当前层数的结点数，next变量记录下一层结点数，line纪录当前遍历层数，每遍历一个当前层数结点，current减一，如果发现current＝＝0，就把下一层入列的结点数变为当前层结点数，进入下一层。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/*struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { }};*//*struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) {}};*/class TreeLevel {public: ListNode* getTreeLevel(TreeNode* root, int dep) { // write code here ListNode* list = new ListNode(-1); ListNode* listHead = list; queue&lt;TreeNode*&gt; que; que.push(root); int current=1,next=0,line=1;//当前层结点个数，下一层结点个数，当前遍历层数 while(!que.empty()){ if(line == dep){ //当前层就是要的层，把队列所有结点插入链表，返回结果链表 for(int i = 0;i &lt; current;i++){ TreeNode* node = que.front(); list-&gt;next = new ListNode(node-&gt;val); list = list-&gt;next; que.pop(); } return listHead-&gt;next; } TreeNode* node = que.front();//取出跟结点 if(node-&gt;left){ //有左子结点 que.push(node-&gt;left); next++; } if(node-&gt;right){ //有右子结点 que.push(node-&gt;right); next++; } que.pop();//弹出根结点 if(--current == 0){ //当前层已全部弹出（全部遍历），进入下一层 current = next; next = 0; line++; } } return listHead-&gt;next; }}; 5. 检查是否为BST 题目描述 请实现一个函数，检查一棵二叉树是否为二叉查找树。 给定树的根结点指针TreeNode* root，请返回一个bool，代表该树是否为二叉查找树。 解法一：中序遍历二叉树，一旦不满足 left &lt;= current &lt; right 的情况则返回 false 1234567891011121314151617181920212223242526272829303132333435363738/*struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { }};*/class Checker {public: bool checkBST(TreeNode* root) { // write code here //最大最小值时，最初的比较数字就应当设置为INT_MAX或INT_MIN，更为安全 //INT_MAX = 2147483647 //INT_MIN = -2147483648 int min = INT_MIN; return ldr(root,min); } bool ldr(TreeNode* root,int &amp;last){ if(root == nullptr){ return true;//当前结点为空 } if(!ldr(root-&gt;left,last)){ return false; } if(root-&gt;val &lt; last){ return false; } last = root-&gt;val; if(!ldr(root-&gt;right,last)){ return false; } return true; }}; 解法二：递归遍历二叉树的过程中，我们只需要传递两个参数（当前根节点对应的二叉树的所有节点的最大值和最小值），同时不断的更新这两个参数，如果当前节点的值不在这两个数范围中，则直接返回false，否则接着递归便可 12345678910111213141516171819202122232425262728/*struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { }};*/class Checker {public: bool checkBST(TreeNode* root) { // write code here int min = INT_MIN; int max = INT_MAX; return checker(root,min,max); } bool checker(TreeNode* root,int min,int max){ if(root == nullptr){ return true; } if(root-&gt;val &lt; min || root-&gt;val &gt; max){ return false; } return checker(root-&gt;left,min,root-&gt;val) &amp;&amp; checker(root-&gt;right,root-&gt;val,max); }}; 6. 寻找下一个结点 题目描述 请设计一个算法，寻找二叉树中指定结点的下一个结点（即中序遍历的后继）。 给定树的根结点指针TreeNode* root和结点的值int p，请返回值为p的结点的后继结点的值。保证结点的值大于等于零小于等于100000且没有重复值，若不存在后继返回-1。 思路：中序遍历所有二叉树，若没找到与p值相同的结点，全部返回-1，一旦找到了，设置引用为true，递归返回结点的值 12345678910111213141516171819202122232425262728293031323334/*struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { }};*/class Successor {public: int findSucc(TreeNode* root, int p) { // write code here bool flag = false; return ldr(root,p,flag); } int ldr(TreeNode* root,int p,bool &amp;flag){ if(root == nullptr){ return -1; } int left = ldr(root-&gt;left,p,flag); if(left != -1){ return left; } if(flag){ return root-&gt;val; } if(root-&gt;val == p){ flag = true; } return ldr(root-&gt;right,p,flag); }};","link":"/2017/08/06/craking%20the%20code%20interview%20%E7%AC%AC%E4%BA%94%E7%89%88%20C++%E5%AE%9E%E7%8E%B0/"},{"title":"计算机网络","text":"一、OSI七层协议 我们需要知道TCP工作在网络OSI的七层模型中的第四层——Transport层，IP在第三层——Network层，ARP在第二层——Data Link层；在第二层上的数据，我们把它叫Frame，在第三层上的数据叫Packet，第四层的数据叫Segment。 同时，我们需要简单的知道，数据从应用层发下来，会在每一层都会加上头部信息，进行封装，然后再发送到数据接收端。这个基本的流程你需要知道，就是每个数据都会经过数据的封装和解封装的过程。 在OSI七层模型中，每一层的作用和对应的协议如下： 二、TCP三次握手，四次挥手 握手 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认； 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。 挥手 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了； 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求； 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态； 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 为什么要三次握手 在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。在另一部经典的《计算机网络》一书中讲“三次握手”的目的是为了解决“网络中存在延迟的重复分组”的问题。 为什么要四次分手 那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。 三、TCP流量控制（滑动窗口） TCP数据流的概念划分类别 已发送已确认 已发送但未确认 未发送而接受方已Ready 未发送而接受方Not Ready 发送窗口和接受窗口 四、TCP丢包重传如果B已经告诉A自己的缓冲区已满，于是A停止发送数据；等待一段时间后，B的缓冲区出现了富余，于是给A发送报文告诉A我的rwnd大小为400，但是这个报文不幸丢失了，于是就出现A等待B的通知||B等待A发送数据的死锁状态。 为了处理这种问题，TCP引入了持续计时器（Persistence timer），当A收到对方的零窗口通知时，就启用该计时器，时间到则发送一个1字节的探测报文，对方会在此时回应自身的接收窗口大小，如果结果仍未0，则重设持续计时器，继续等待。 五、拥塞控制 慢开始，拥塞控制 发送方维持一个叫做“拥塞窗口”的变量，该变量和接收端口共同决定了发送者的发送窗口； 当主机开始发送数据时，避免一下子将大量字节注入到网络，造成或者增加拥塞，选择发送一个1字节的试探报文； 当收到第一个字节的数据的确认后，就发送2个字节的报文； 若再次收到2个字节的确认，则发送4个字节，依次递增2的指数级； 最后会达到一个提前预设的“慢开始门限”，比如24，即一次发送了24个分组，此时遵循下面的条件判定： cwnd &lt; ssthresh， 继续使用慢开始算法； cwnd &gt; ssthresh，停止使用慢开始算法，改用拥塞避免算法； cwnd = ssthresh，既可以使用慢开始算法，也可以使用拥塞避免算法； 所谓拥塞避免算法就是：每经过一个往返时间RTT就把发送方的拥塞窗口+1，即让拥塞窗口缓慢地增大，按照线性规律增长； 当出现网络拥塞，比如丢包时，将慢开始门限设为原先的一半，然后将cwnd设为1，执行慢开始算法（较低的起点，指数级增长）； 快重传，快恢复 接收方建立这样的机制，如果一个包丢失，则对后续的包继续发送针对该包的重传请求； 一旦发送方接收到三个一样的确认，就知道该包之后出现了错误，立刻重传该包； 此时发送方开始执行“快恢复”算法： 慢开始门限减半； cwnd设为慢开始门限减半后的数值； 执行拥塞避免算法（高起点，线性增长）；","link":"/2017/08/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"title":"正则表达式","text":"一、比较常见的元字符1234567. 匹配除了换行符(\\n)之外的任意字符\\d 匹配一个数字字符，等价于[0-9]\\w 匹配字母或者数字或者下划线或者汉字\\b 匹配单词的开始或结束\\s 匹配空格^ 匹配字符串的开始$ 匹配字符串的结束 二、反义1234\\D 匹配任意非数字的字符\\W 匹配任意不是字母，数字，下划线，汉字的字符\\B 匹配不是单词开头或结束的位置[^x] 匹配除了x以外的任意字符 三、限定符123456* 重复0次或者更多次+ 重复1次或更多次? 重复0次或者1次（可以理解为存在或者不存在）{n} 重复n次{n,} 重复n次或更多次{n,m} 重复n到m次 四、(括号)、[中括号]、{大括号}的区别 () 是为了提取匹配的字符串。表达式中有几个()就有几个相应的匹配字符串。 eg : (\\s*)表示连续空格的字符串。 []是定义匹配的字符范围。 eg : [a-zA-Z0-9] 表示相应位置的字符要匹配英文字符和数字。[\\s*]表示空格或者*号。 {}一般用来表示匹配的长度 eg : \\s{3} 表示匹配三个空格，\\s[1,3]表示匹配一到三个空格。 五、分支｜相当于“或”，比如 (\\d{2}|\\d{3})，就是2位数字或3为数字的意思 六、模式修正符 /i (忽略大小写) /g (全文查找出现的所有匹配字符) /m (多行查找) /gi(全文查找、忽略大小写) /ig(全文查找、忽略大小写) /s (如果设置了这个修饰符，模式中的点号元字符匹配所有字符，包含换行符。如果没有这个 修饰符，点号不匹配换行符) /x (如果设置了这个修饰符，模式中的没有经过转义的或不在字符类中的空白数据字符总会被忽略， 并且位于一个未转义的字符类外部的#字符和下一个换行符之间的字符也被忽略) 七、零宽度断言就是本身不占字符宽度，仅仅为断言，分为前置匹配和后置匹配 前置匹配（loosbehinds）?&lt;= , ?&lt;!表否定 (?&lt;=abc)表示匹配到了abc才匹配后面的内容 (?&lt;!abc)edf表示匹配不到abc才匹配edf 后置匹配（lookheads）?= , ?!表否定 abc(?=edf)表示abc后面紧跟edf才匹配 abc(?!edf)表示abc后面不紧跟edf才匹配","link":"/2017/08/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"排序算法","text":"总结http://blog.csdn.net/hr10707020217/article/details/10581371 注意：这里的排序默认从小到大 冒泡排序 策略 比较相邻的元素，如果第一个比第二个大，则交换 实现 1234567891011121314151617void bubbleSort(int[] arr){ for(int i = 0;i &lt; arr.length - 1;i++){ for(int j = length - 1;j &gt; i;j--){ if(arr[j] &lt; arr[j-1]){ swap(j,j-1,arr); } } } }void swap(int a,int b,int[] arr){ int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp;} 优化 某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。用一个标记记录这个状态即可。 记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不用再排序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。 选择排序 策略 在未排序序列中找到最小元素，存放到排序序列的起始位置，对每个元素都做统一操作直到遍历完所有元素 实现 12345678910111213141516171819202122void selectSort(int[] arr){ int min_index; for(int i = 0;i &lt; arr.length;i++){ min_index = i; for(int j = i;j &lt; arr.length;j++){ if(arr[j] &lt; arr[min_index]){ min_index = j; } } if(i != min_index){ swap(i,min_index.arr); } }}void swap(int a,int b,int[] arr){ int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp;} 插入排序 策略 第一个元素默认有序，在序列中取下一个元素，在已经排序的序列中从后往前扫描，发现比当前元素小的元素全部后移一位，直到找到元素小于或等于当前元素，然后将当前元素插入该位置 实现 123456789101112void insertSort(int[] arr){ for(int i = 1;i &lt; arr.length;i++){ int j = i; int target = arr[i]; while(j &gt; 0 &amp;&amp; target &lt; arr[j-1]){ a[j] = a[j-1]; j--; } arr[j] = target; }} 演示 希尔排序 策略 将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。直到整个表就只有一列，则为有序。 实现 12345678910111213141516171819void shellSort(int[] arr){ int t;//增量 int target; int n = arr.length; for(t = n/2;t &gt; 0;t /= 2){//两倍缩小增量 for(int i = t;i &lt; n;i++){//遍历每一列 target = a[i];//需要插入的元素 for(int j = i;j &gt;= t;j--){ if(target &lt; a[j-t]){ a[j] = a[j-t];//后移t位 }else{ break; } } a[j] = target;//插入 } }} 归并排序 策略 先递归分解数组,直至分解出的小组只含有一个元素时为止，此时数组内部就是有序的，再合并数组 实现 1234567891011121314151617181920212223242526272829303132333435363738394041void main(int[] arr){ int first = 0; int last = arr.length - 1; int[] res[10000]; mergeSort(arr,start,last,res);}void mergeSort(int[] arr,int first,int last,int[] res){ if(first &lt; last){ int mid = (first + last) / 2; mergeSort(arr,first,mid,res);//递归左数组 mergeSort(arr,mid+1,last,res);//递归右数组 mergeArray(arr,first,mid,last,res);//合并数组}void mergeArray(int[] arr,int first,int mid,int last,int[] res){ int i = first,j = mid + 1; int m = mid, n = last; int k = 0; while(i &lt;= m &amp;&amp; j &lt;=n){ if(arr[i] &lt;= arr[j]){ res[k++] = arr[i++]; }else{ res[k++] = arr[j++]; } } //防止漏网之鱼 while(i &lt;= m){ res[k++] = arr[i++]; } while(j &lt;= n){ res[k++] = arr[i++]; } //合并到总数组 for(i = 0;i &lt; k;i++){ a[first + i] = res[i]; }} 演示 快速排序 策略 从数列中挑出一个元素作为基准数。 分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。 再对左右区间递归执行第二步，直至各区间只有一个数。 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445void main(int[] arr){ int left = 0; int right = arr.length-1; quickSort(arr,left,right);}void quickSort(int[] arr,int left,int right){ if(left &gt;= right){ return ; } int pivot = partition(arr,left,right);//分区 quickSort(arr,left,pivot - 1);//递归左序列分区 quickSort(arr,pivot,right);//递归有序列分区}int partition(int[] arr,int left,int right){ int pivot_value = arr[left];//左边第一个数作为基准值 int pivot = left; while(left &lt; right){//左右指针相遇则交换 while(left &lt; right &amp;&amp; arr[right] &gt;= pivot_value){ //右指针先走，往左找比基准值小得数，未找到则继续前进 right--; } while(left &lt; right &amp;&amp; arr[left] &lt;= pivot_val){ //右指针找到后，走指针往右走，找比基准值大的数，未找到则继续前进 left++; } //左右指针都找到目标，交换左右指针的值 swap(left,right,arr); } //左右指针已经相遇（跳出最外层循环），交换左指针与基准 swap(left,pivot,arr); //返回左指针作为下一次递归左右子序列的基准值 return left;}void swap(int a,int b,int[] arr){ int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp;} 演示 堆排序 策略 利用二叉堆的特性: lchirld = 2*i + 1 rchirld = 2*i + 2 一、初始化堆（构建大顶堆） 找到最后一个非叶子节点 i = arr.length / 2 判断 i &lt; length / 2则调整，防止出现双数情况算法出错，否则 i– 再调整 分别判断左右子节点是否大于当前节点，是则交换 判断是否发生了交换，如果是，子堆可能被打乱，需要递归重复调整，把交换的及诶单下表作为 i 传入递归函数中 重复 2 3 4直到 i– &lt; 0 二、把堆顶元素(最大)与最后一个元素交换，形成无序区、有序区， 实现 12345678910111213141516171819202122232425262728293031323334353637383940void heapSort(int[] arr){ int length = arr.length; buildHeap(arr,length); for(int i = length - 1;i &gt; 0;i--){ swap(i,0,arr); adjustHeap(arr,0,i); }}void buildHeap(int[] arr,int length){ for(int i = length / 2;i &gt; 0;i--){ adjustHeap(arr,i,length); }}void adjustHeap(int[] arr,int i,int length){ int lchirld = i * 2 + 1; int rchirld = i * 2 + 2; int max = i; if(lchirld &lt; length &amp;&amp; arr[max] &lt; arr[lchirld]){ max = lchirld; } if(rchirld &lt; length &amp;&amp; arr[max] &lt; arr[rchirld]){ max = rchirld; } if(max != i){ swap(arr,max,i); adjustHeap(arr,max,length); }}void swap(int a,int b,int[] arr){ int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp;} 演示 计数排序 策略 找出待排序的数组中最大和最小的元素 统计数组中每个值为i的元素出现的次数，存入数组C的第i项 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加） 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1 实现 123456789101112131415161718192021222324252627282930#define NUM_RANGE (100) //预定义数据范围上限，即K的值void countingSort(int *ini_arr, int *sorted_arr, int n) //所需空间为 2*n+k{ int *count_arr = (int *)malloc(sizeof(int) * NUM_RANGE); int i, j, k; //初始化统计数组元素为值为零 for(k=0; k&lt;NUM_RANGE; k++){ count_arr[k] = 0; } //统计数组中，每个元素出现的次数 for(i=0; i&lt;n; i++){ count_arr[ini_arr[i]]++; } //统计数组计数，每项存前N项和，这实质为排序过程 for(k=1; k&lt;NUM_RANGE; k++){ count_arr[k] += count_arr[k-1]; } //将计数排序结果转化为数组元素的真实排序结果 for(j=n-1 ; j&gt;=0; j--){ int elem = ini_arr[j]; //取待排序元素 int index = count_arr[elem]-1; //待排序元素在有序数组中的序号 sorted_arr[index] = elem; //将待排序元素存入结果数组中 count_arr[elem]--; //修正排序结果，其实是针对算得元素的修正 } free(count_arr); } 桶排序桶排序是计数排序的变种，把计数排序中相邻的m个”小桶”放到一个”大桶”中，在分完桶后，对每个桶进行排序（一般用快排），然后合并成最后的结果。 基本思想： 桶排序假设序列由一个随机过程产生，该过程将元素均匀而独立地分布在区间[0,1)上。我们把区间[0,1)划分成n个相同大小的子区间，称为桶。将n个记录分布到各个桶中去。如果有多于一个记录分到同一个桶中，需要进行桶内排序。最后依次把各个桶中的记录列出来记得到有序序列。","link":"/2017/08/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"配置 MySQL 远程连接","text":"配置打开 iptables 3306端口 如果你是 CentOS 系列 12iptables -I INPUT 4 -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPTservice iptables save #保存iptables规则 如果你是 Ubuntu/Debian 系列 12iptables -I INPUT 4 -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPTiptables-save &gt; /etc/iptables.up.rules #保存iptables规则 创建用户 登录你的远程服务器 1ssh root@your domain.com 登录 MySQL 1mysql -u root -p 创建用户（用户名不能是root） 1create user 用户名 identified by '密码'; 授权用户 MySQL 5.7 1grant all on 数据库名.* to 用户名 MySQL 5.6 1grant all privileges on 数据库名.* to 用户名@’%’ identified by ‘用户密码’; 如果出现 ERROR 1524 (HY000): Plugin ‘*9E53930467B20A15727780FB02007B379CE21A84’ is not loaded 尝试删除用户在重复以上步骤","link":"/2017/05/17/%E9%85%8D%E7%BD%AE%20MySQL%20%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"},{"title":"设计模式","text":"一、六大原则(SOLID) 单一职责 Single responsibility Principle 不要存在多于一个导致类修改的原因。通俗地说，一个类仅负责一项职责 开放关闭原则 Open-Close Principle 一个软件实体应该对扩展开放，对修改关闭 里氏替换原则 Liskov substitution Principle 所有引用基类的地方必须能够透明地使用其子类的对象 接口隔离原则 Interface segregation Principle 一个类对另一个类的依赖应该建立在最小的接口上 依赖倒置原则 Dependence Inversion Principle 依赖抽象，而非细节 最小知识原则·迪米特原则 Least Knowledge Principle 一个类应该对其他类有最少的了解 参考：http://wiki.jikexueyuan.com/project/java-design-pattern-principle/principle-1.html 二、创建型模式 简单工厂模式 工厂方法模式 抽象工厂模式 生成器模式 原型模式 单例模式 参考：https://mp.weixin.qq.com/s?__biz=MzAwNjMxMTA5Mw==&amp;mid=2651340464&amp;idx=1&amp;sn=9fc4c3863154faebcec2b00f5460744e&amp;chksm=80f3c36ab7844a7cedff16c1525ea9d6aef1af2c3634407c110c1711ac935276d970ad84056e&amp;scene=0&amp;key=a9f0cd582f409b4ec7d6d5a6b35474e8e9e6446ff792c5af556020bd5d1266470be53b702a9fa37134e73e12bb0b97955a6226696ee41e4c26db02974daab878507a39ee16961a126b64ad37531be248&amp;ascene=0&amp;uin=MTUwMDI3MTU4NA%3D%3D&amp;devicetype=iMac+MacBookPro11%2C4+OSX+OSX+10.11.6+build 三、结构型模式 适配器模式 桥接模式 组合模式 修饰模式 外观模式 享元模式 代理模式 参考：https://mp.weixin.qq.com/s?__biz=MzAwNjMxMTA5Mw==&amp;mid=2651340466&amp;idx=1&amp;sn=ce8803faa74406679b43ecf89689e306&amp;chksm=80f3c368b7844a7e2e02b2c9bb65e8049e2b58997244aa01c5c996fc1149780a14c9408af0a5&amp;scene=0&amp;key=5bc881ac3c593efc9e70410968ebde043ec6d8f2598f515b99cef82c76da6327127928cc7d89a03603ac362134c7cb7915b39a9819a6ca94f84da971b8924e96ef81131588c25cf11587d337b0d77b24&amp;ascene=0&amp;uin=MTUwMDI3MTU4NA%3D%3D&amp;devicetype=iMac+MacBookPro11%2C4+OSX+OSX+10.11.6+build 四、行为型模式 责任链模式 命令模式 迭代器模式 中介者模式 备忘录模式 观察者模式 访问者模式 策略模式 状态模式 模板方法模式 参考：https://mp.weixin.qq.com/s?__biz=MzAwNjMxMTA5Mw==&amp;mid=2651340469&amp;idx=1&amp;sn=59ef8698c30deafa865d9af72e1c1b1e&amp;chksm=80f3c36fb7844a79c46aa5f78288211903e38f56b8b061947e580c12f95801c0a7fadd2fb761&amp;scene=0&amp;key=a9f0cd582f409b4ea5d0df86c439d2030c92e7dd0ff5f139d0d6716138b5e0d9284b78a6d9f07a408f62932a7012013481a87e98cb231dc379dc33cbb2f65c6eb5e52315b1bbe1d97df8b39b7c40bca3&amp;ascene=0&amp;uin=MTUwMDI3MTU4NA%3D%3D&amp;devicetype=iMac+MacBookPro11%2C4+OSX+OSX+10.11.6+build","link":"/2017/08/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Laravel","slug":"Laravel","link":"/tags/Laravel/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"测试","slug":"测试","link":"/tags/%E6%B5%8B%E8%AF%95/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Design","slug":"Design","link":"/tags/Design/"},{"name":"正则","slug":"正则","link":"/tags/%E6%AD%A3%E5%88%99/"},{"name":"单元测试","slug":"单元测试","link":"/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}],"categories":[{"name":"PHP","slug":"PHP","link":"/categories/PHP/"},{"name":"测试","slug":"测试","link":"/categories/%E6%B5%8B%E8%AF%95/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"Database","slug":"Database","link":"/categories/Database/"},{"name":"基础","slug":"基础","link":"/categories/%E5%9F%BA%E7%A1%80/"},{"name":"设计","slug":"设计","link":"/categories/%E8%AE%BE%E8%AE%A1/"}],"pages":[]}